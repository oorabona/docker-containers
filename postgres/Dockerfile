# PostgreSQL Container with Extension Flavors
#
# Flavors:
#   - base:        Built-in extensions only (default)
#   - vector:      + pgvector for AI/RAG
#   - analytics:   + pg_partman, hypopg, pg_qualstats
#   - timeseries:  + timescaledb for time-series data
#   - distributed: + citus for horizontal scaling
#   - full:        All Alpine-compatible extensions
#
# NOTE: search flavor (ParadeDB) disabled - requires Debian for pgrx compilation
#
# Usage:
#   docker build --build-arg VERSION=17-alpine --build-arg FLAVOR=vector .
#
# Extension images are pulled from registry and files are copied using COPY --from=
# Build extension images first: ./scripts/build-extensions.sh postgres

ARG VERSION=17-alpine
ARG MAJOR_VERSION=17

# ============================================================================
# Base Image Registry
# CI uses cached base images from GHCR to avoid Docker Hub rate limits
# Default: postgres (Docker Hub) for local builds and fallback
# CI overrides with: --build-arg BASE_IMAGE=ghcr.io/oorabona/postgres-base
# ============================================================================
ARG BASE_IMAGE=postgres

# ============================================================================
# Extension Stages - Generated by generate_dockerfile()
# Only extensions compatible with this flavor+PG version are included
# Run: source helpers/extension-utils.sh && generate_dockerfile \
#   postgres/extensions/config.yaml postgres/Dockerfile <flavor> <pg_major>
# ============================================================================
# @@EXTENSION_STAGES@@

# ============================================================================
# Main Image
# Uses cached base image from GHCR (or Docker Hub for local builds)
# ============================================================================
ARG BASE_IMAGE
ARG VERSION
FROM ${BASE_IMAGE}:${VERSION}

# Build arguments
ARG FLAVOR=base
ARG LOCALES=
ARG SHARED_PRELOAD_LIBRARIES=pg_stat_statements

# Labels
LABEL org.opencontainers.image.title="PostgreSQL ${FLAVOR}"
LABEL org.opencontainers.image.description="PostgreSQL with ${FLAVOR} extensions"
LABEL org.opencontainers.image.vendor="oorabona"
LABEL flavor="${FLAVOR}"

# Install locales if specified
RUN if [ -n "${LOCALES}" ]; then \
        for l in ${LOCALES}; do \
            localedef -i $l -c -f UTF-8 -A /usr/share/locale/locale.alias ${l}.UTF-8; \
        done; \
    fi

# ============================================================================
# Copy extensions based on flavor
# Extensions are copied to staging directories, then installed conditionally
# ============================================================================

# Extension files - Generated by generate_dockerfile()
# Only extensions for this flavor+PG version are copied
# @@EXTENSION_COPIES@@

# Install extensions based on flavor
RUN set -eux; \
    # Function to install an extension from staging
    install_ext() { \
        local ext=$1; \
        if [ -d "/tmp/ext/${ext}/extension" ]; then \
            echo "Installing extension: ${ext}"; \
            cp -v /tmp/ext/${ext}/extension/* /usr/local/share/postgresql/extension/ 2>/dev/null || true; \
            cp -v /tmp/ext/${ext}/lib/* /usr/local/lib/postgresql/ 2>/dev/null || true; \
        fi; \
    }; \
    \
    # Install extensions based on flavor
    # WARNING: This mapping must stay in sync with the flavors section
    # in extensions/config.yaml. If you add/remove an extension from a flavor
    # there, update the corresponding case branch here as well.
    case "${FLAVOR}" in \
        base) \
            echo "Base flavor: no compiled extensions" \
            ;; \
        vector) \
            install_ext pgvector \
            ;; \
        analytics) \
            install_ext pg_partman; \
            install_ext hypopg; \
            install_ext pg_qualstats \
            ;; \
        timeseries) \
            install_ext timescaledb; \
            install_ext pg_partman \
            ;; \
        distributed) \
            install_ext citus \
            ;; \
        full) \
            install_ext pgvector; \
            install_ext pg_partman; \
            install_ext hypopg; \
            install_ext pg_qualstats; \
            install_ext citus; \
            install_ext timescaledb \
            ;; \
        *) \
            echo "Unknown flavor: ${FLAVOR}"; \
            exit 1 \
            ;; \
    esac; \
    \
    # Cleanup staging directory
    rm -rf /tmp/ext

# Create initialization script for all built-in extensions
# These are bundled with standard PostgreSQL — no compilation needed
# All flavors get them; zero overhead until explicitly used
RUN printf '%s\n' \
    '-- Built-in PostgreSQL extensions (available in all flavors)' \
    '' \
    '-- Statistics and monitoring' \
    'CREATE EXTENSION IF NOT EXISTS pg_stat_statements;' \
    'CREATE EXTENSION IF NOT EXISTS pg_buffercache;' \
    'CREATE EXTENSION IF NOT EXISTS pg_prewarm;' \
    '' \
    '-- Cryptography' \
    'CREATE EXTENSION IF NOT EXISTS pgcrypto;' \
    '' \
    '-- Data types and indexing' \
    'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";' \
    'CREATE EXTENSION IF NOT EXISTS btree_gin;' \
    'CREATE EXTENSION IF NOT EXISTS btree_gist;' \
    'CREATE EXTENSION IF NOT EXISTS pg_trgm;' \
    '' \
    '-- Foreign data wrappers' \
    'CREATE EXTENSION IF NOT EXISTS file_fdw;' \
    'CREATE EXTENSION IF NOT EXISTS postgres_fdw;' \
    '' \
    '-- Administration' \
    'CREATE EXTENSION IF NOT EXISTS adminpack;' \
    > /docker-entrypoint-initdb.d/00-init-extensions.sql

# Create flavor-specific initialization script for compiled extensions only
# Built-in extensions are already in 00-init-extensions.sql (all flavors)
# This case block mirrors config.yaml flavors — only compiled extensions here
RUN case "${FLAVOR}" in \
        vector) \
            printf '%s\n' \
                '-- Vector flavor: compiled extensions' \
                'CREATE EXTENSION IF NOT EXISTS vector;' \
                > /docker-entrypoint-initdb.d/01-init-flavor.sql \
            ;; \
        analytics) \
            printf '%s\n' \
                '-- Analytics flavor: compiled extensions' \
                'CREATE EXTENSION IF NOT EXISTS pg_partman;' \
                'CREATE EXTENSION IF NOT EXISTS hypopg;' \
                'CREATE EXTENSION IF NOT EXISTS pg_qualstats;' \
                > /docker-entrypoint-initdb.d/01-init-flavor.sql \
            ;; \
        timeseries) \
            printf '%s\n' \
                '-- TimescaleDB flavor: compiled extensions' \
                'CREATE EXTENSION IF NOT EXISTS timescaledb;' \
                'CREATE EXTENSION IF NOT EXISTS pg_partman;' \
                > /docker-entrypoint-initdb.d/01-init-flavor.sql \
            ;; \
        distributed) \
            printf '%s\n' \
                '-- Citus distributed flavor: compiled extensions' \
                'CREATE EXTENSION IF NOT EXISTS citus;' \
                > /docker-entrypoint-initdb.d/01-init-flavor.sql \
            ;; \
        full) \
            printf '%s\n' \
                '-- Full flavor: compiled extensions' \
                'CREATE EXTENSION IF NOT EXISTS vector;' \
                'CREATE EXTENSION IF NOT EXISTS pg_partman;' \
                'CREATE EXTENSION IF NOT EXISTS hypopg;' \
                'CREATE EXTENSION IF NOT EXISTS pg_qualstats;' \
                'CREATE EXTENSION IF NOT EXISTS citus;' \
                'CREATE EXTENSION IF NOT EXISTS timescaledb;' \
                > /docker-entrypoint-initdb.d/01-init-flavor.sql \
            ;; \
    esac

# Configure shared_preload_libraries based on actually installed extensions
# Detects which extensions need preloading by checking for their .so files
# Order matters: citus must be first, then timescaledb, then others
#
# IMPORTANT: We modify postgresql.conf.sample so that initdb creates a config
# with shared_preload_libraries already set. This is required because the
# temporary postgres server during initdb must have these libraries loaded
# BEFORE the init scripts try to CREATE EXTENSION.
RUN PRELOAD=""; \
    # Citus must be loaded first if present
    if [ -f /usr/local/lib/postgresql/citus.so ]; then \
        PRELOAD="citus"; \
    fi; \
    # TimescaleDB should be loaded early
    if ls /usr/local/lib/postgresql/timescaledb*.so 1>/dev/null 2>&1; then \
        PRELOAD="${PRELOAD:+$PRELOAD,}timescaledb"; \
    fi; \
    # pg_stat_statements is always available (built-in)
    PRELOAD="${PRELOAD:+$PRELOAD,}pg_stat_statements"; \
    # pg_qualstats if present
    if [ -f /usr/local/lib/postgresql/pg_qualstats.so ]; then \
        PRELOAD="${PRELOAD:+$PRELOAD,}pg_qualstats"; \
    fi; \
    # Save for reference
    echo "$PRELOAD" > /etc/postgresql-preload.conf; \
    # Modify postgresql.conf.sample so initdb creates config with preload libraries
    # This ensures the temporary server during initdb has the libraries loaded
    if [ -n "$PRELOAD" ]; then \
        echo "" >> /usr/local/share/postgresql/postgresql.conf.sample; \
        echo "# Preloaded extensions (configured at build time)" >> /usr/local/share/postgresql/postgresql.conf.sample; \
        echo "shared_preload_libraries = '$PRELOAD'" >> /usr/local/share/postgresql/postgresql.conf.sample; \
    fi; \
    echo "Configured shared_preload_libraries: $PRELOAD"

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD pg_isready -U ${POSTGRES_USER:-postgres} || exit 1

# Expose standard PostgreSQL port
EXPOSE 5432

# Use the default postgres entrypoint - shared_preload_libraries is already
# configured in postgresql.conf.sample so it's applied during initdb
