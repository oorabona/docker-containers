name: Build Container
description: Smart container build with multi-platform and multi-registry support
inputs:
  container:
    description: Container name to build
    required: true
  version:
    description: Version to build (if empty, will be auto-detected)
    required: false
    default: ''
  tag:
    description: Image tag (may differ from version for variants)
    required: false
    default: ''
  flavor:
    description: Build flavor for variant containers (passed as FLAVOR build arg)
    required: false
    default: ''
  variant:
    description: Variant name (for logging/identification)
    required: false
    default: ''
  dockerfile:
    description: Custom Dockerfile to use (relative to container directory, defaults to Dockerfile)
    required: false
    default: ''
  platform:
    description: Target platform (e.g., linux/amd64 or linux/arm64)
    required: false
    default: 'linux/amd64'
  force_rebuild:
    description: Force rebuild even if image exists
    required: false
    default: 'false'
  dockerhub_username:
    description: Docker Hub username
    required: false
  dockerhub_token:
    description: Docker Hub token
    required: false
  github_token:
    description: GitHub token for GHCR
    required: true
  scan_vulnerabilities:
    description: Enable Trivy vulnerability scanning (true/false)
    required: false
    default: 'true'
  vulnerability_severity:
    description: Minimum severity to fail build (CRITICAL, HIGH, MEDIUM, LOW)
    required: false
    default: 'CRITICAL'
outputs:
  built:
    description: Whether the container was built
    value: ${{ steps.check-build.outputs.needs_build }}
  version:
    description: Container version that was built
    value: ${{ steps.check-build.outputs.current_version }}
  tag:
    description: Image tag that was built (may differ from version for variants)
    value: ${{ steps.check-build.outputs.current_tag }}
  image_name:
    description: Full image name
    value: ${{ steps.check-build.outputs.image_name }}
  ghcr_pushed:
    description: Whether GHCR push succeeded
    value: ${{ steps.push-ghcr.outputs.success }}
  dockerhub_pushed:
    description: Whether Docker Hub push succeeded
    value: ${{ steps.push-dockerhub.outputs.success }}
  scan_passed:
    description: Whether security scan passed (or was skipped)
    value: ${{ steps.trivy-scan.outcome != 'failure' || inputs.scan_vulnerabilities != 'true' }}
runs:
  using: composite
  steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      # Uses docker-container driver (default) which supports --push
      # GitHub runners cache moby/buildkit images, so Docker Hub dependency is minimal
      # Retry logic handles intermittent Docker Hub issues

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ inputs.github_token }}

    - name: Log in to Docker Hub
      if: ${{ inputs.dockerhub_username != '' && inputs.dockerhub_token != '' }}
      id: dockerhub-login
      uses: docker/login-action@v3
      with:
        registry: docker.io
        username: ${{ inputs.dockerhub_username }}
        password: ${{ inputs.dockerhub_token }}
      continue-on-error: true

    - name: Check if build is needed and get version
      id: check-build
      shell: bash
      run: |
        set -e
        container="${{ inputs.container }}"
        variant="${{ inputs.variant }}"
        flavor="${{ inputs.flavor }}"
        dockerfile="${{ inputs.dockerfile }}"

        # Default to Dockerfile if not specified
        [[ -z "$dockerfile" ]] && dockerfile="Dockerfile"

        # Check if the container directory exists and has the specified Dockerfile
        if [[ ! -f "$container/$dockerfile" ]]; then
          echo "::error::Dockerfile '$dockerfile' not found for $container"
          echo "needs_build=false" >> $GITHUB_OUTPUT
          echo "current_version=latest" >> $GITHUB_OUTPUT
          echo "current_tag=latest" >> $GITHUB_OUTPUT
          echo "image_name=${{ github.repository_owner }}/${container}" >> $GITHUB_OUTPUT
          echo "flavor=" >> $GITHUB_OUTPUT
          echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Set image names
        github_username="${{ github.repository_owner }}"
        image_name="${github_username}/${container}"

        # Get current version for tagging
        # Priority: 1) input version, 2) ./make version, 3) fallback to "latest"
        current_version="${{ inputs.version }}"

        if [[ -n "$current_version" && "$current_version" != "unknown" && "$current_version" != "latest" ]]; then
          echo "::notice::Using provided version: $current_version"
        elif current_version=$(./make version "$container" 2>/dev/null); then
          if [[ -n "$current_version" && "$current_version" != "unknown" ]]; then
            echo "::notice::Detected version: $current_version"
          else
            current_version="latest"
            echo "::notice::Using fallback version: $current_version"
          fi
        else
          current_version="latest"
          echo "::notice::Using fallback version: $current_version"
        fi

        # Use tag input if provided, otherwise use version
        current_tag="${{ inputs.tag }}"
        if [[ -z "$current_tag" ]]; then
          current_tag="$current_version"
        fi

        # Variant/flavor info
        if [[ -n "$variant" ]]; then
          echo "::notice::Building variant: $variant (tag: $current_tag, flavor: $flavor)"
        fi

        # Determine if build is needed
        if [ "${{ inputs.force_rebuild }}" = "true" ]; then
          echo "::notice::Force rebuild requested"
          needs_build=true
        elif [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "::notice::Code changes detected - build needed"
          needs_build=true
        else
          echo "::notice::Manual/scheduled build"
          needs_build=true
        fi

        # Extract platform suffix from platform input (e.g., linux/amd64 -> amd64)
        platform="${{ inputs.platform }}"
        platform_suffix="${platform##*/}"

        echo "needs_build=$needs_build" >> $GITHUB_OUTPUT
        echo "current_version=$current_version" >> $GITHUB_OUTPUT
        echo "current_tag=$current_tag" >> $GITHUB_OUTPUT
        echo "image_name=$image_name" >> $GITHUB_OUTPUT
        echo "flavor=$flavor" >> $GITHUB_OUTPUT
        echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
        echo "platform_suffix=$platform_suffix" >> $GITHUB_OUTPUT

    - name: Run container prebuild (if exists)
      if: ${{ steps.check-build.outputs.needs_build == 'true' }}
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        container="${{ inputs.container }}"
        current_version="${{ steps.check-build.outputs.current_version }}"

        # Check if prebuild script exists
        if [[ -x "$container/prebuild.sh" ]]; then
          echo "::group::Running prebuild for $container"

          # Extract major version for extensions
          pg_major=$(echo "$current_version" | grep -oE '^[0-9]+' | head -1)

          "$container/prebuild.sh" "$pg_major" || {
            echo "::warning::Prebuild script failed (non-fatal)"
          }

          echo "::endgroup::"
        fi

    - name: Build container
      if: ${{ steps.check-build.outputs.needs_build == 'true' }}
      id: build
      shell: bash
      env:
        BUILD_PLATFORM: ${{ inputs.platform }}
        GH_TOKEN: ${{ inputs.github_token }}
        FORCE_REBUILD: ${{ inputs.force_rebuild }}
      run: |
        set -euo pipefail
        source ./helpers/logging.sh
        source ./helpers/variant-utils.sh

        container="${{ inputs.container }}"
        current_version="${{ steps.check-build.outputs.current_version }}"
        current_tag="${{ steps.check-build.outputs.current_tag }}"
        flavor="${{ steps.check-build.outputs.flavor }}"
        variant="${{ inputs.variant }}"
        dockerfile="${{ steps.check-build.outputs.dockerfile }}"

        # Log build info
        if [[ -n "$variant" ]]; then
          echo "::group::Building $container:$current_tag (variant: $variant, dockerfile: $dockerfile) for $BUILD_PLATFORM"
        else
          echo "::group::Building $container:$current_tag (dockerfile: $dockerfile) for $BUILD_PLATFORM"
        fi

        # Compute SKIP_EXISTING_BUILDS in-step
        if [[ "${{ github.event_name }}" != "pull_request" && "${FORCE_REBUILD}" != "true" ]]; then
          export SKIP_EXISTING_BUILDS="true"
        else
          export SKIP_EXISTING_BUILDS="false"
        fi

        # For postgres: use GHCR cached base images if available
        # This avoids Docker Hub rate limits (200 pulls/6h)
        # IMPORTANT: build_version is used for --build-arg VERSION in Dockerfile
        # - For postgres: must be base_tag (e.g., "17-alpine") for FROM postgres:VERSION
        # - For other containers: use current_version as-is
        build_version="$current_version"

        if [[ "$container" == "postgres" ]]; then
          owner="${{ github.repository_owner }}"
          base_sfx=$(base_suffix "./$container")
          [[ -z "$base_sfx" ]] && base_sfx="-alpine"
          base_tag="${current_version}${base_sfx}"
          build_version="$base_tag"

          cache_image="ghcr.io/$owner/postgres-base:${base_tag}"
          echo "Checking for cached base image: $cache_image"
          if docker pull --quiet "$cache_image" &>/dev/null; then
            echo "✅ Using cached base image: $cache_image (for all variants)"
            export CUSTOM_BUILD_ARGS="--build-arg BASE_IMAGE=ghcr.io/$owner/postgres-base"
          else
            echo "⚠️ Cache not available for $cache_image, using Docker Hub directly"
          fi
        fi

        # Build via ./make — sources container build files, handles CUSTOM_BUILD_ARGS
        make_args=("build" "$container" "$build_version")
        [[ -n "$current_tag" ]] && make_args+=("$current_tag")
        [[ -n "$flavor" ]] && make_args+=("--flavor" "$flavor")
        [[ -n "$dockerfile" && "$dockerfile" != "Dockerfile" ]] && make_args+=("--dockerfile" "$dockerfile")

        log_info "Calling: ./make ${make_args[*]}"
        if ! ./make "${make_args[@]}"; then
          echo "::error::Build failed for $container:$current_tag"
          exit 1
        fi

        echo "::endgroup::"
        echo "::notice::Build successful for $container:$current_tag"

    # Security Scanning with Trivy
    # Note: Image is tagged as ghcr.io/owner/container:version by the build step
    - name: Ensure Trivy cache directory exists
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' }}
      shell: bash
      run: mkdir -p ~/.cache/trivy

    - name: Cache Trivy vulnerability database
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' }}
      uses: actions/cache@v4
      with:
        path: ~/.cache/trivy
        key: trivy-db-${{ runner.os }}-${{ hashFiles('.github/actions/build-container/action.yaml') }}
        restore-keys: |
          trivy-db-${{ runner.os }}-

    - name: Scan for vulnerabilities (Trivy)
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' }}
      id: trivy-scan
      uses: aquasecurity/trivy-action@0.29.0
      with:
        image-ref: 'ghcr.io/${{ steps.check-build.outputs.image_name }}:${{ steps.check-build.outputs.current_tag }}'
        format: 'table'
        exit-code: '1'
        severity: '${{ inputs.vulnerability_severity }},CRITICAL'
        ignore-unfixed: true
        vuln-type: 'os,library'
        cache-dir: ~/.cache/trivy
      continue-on-error: true  # Scan is advisory - don't block builds on scan failures

    - name: Generate SARIF report
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' && always() }}
      uses: aquasecurity/trivy-action@0.29.0
      with:
        image-ref: 'ghcr.io/${{ steps.check-build.outputs.image_name }}:${{ steps.check-build.outputs.current_tag }}'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL'
        ignore-unfixed: true
        vuln-type: 'os,library'
        cache-dir: ~/.cache/trivy
      continue-on-error: true

    - name: Upload SARIF to GitHub Security
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' && always() }}
      uses: github/codeql-action/upload-sarif@v4
      with:
        sarif_file: 'trivy-results.sarif'
        category: 'container-${{ inputs.container }}-${{ steps.check-build.outputs.current_tag }}'
        wait-for-processing: false
      continue-on-error: true  # Don't fail if SARIF upload fails (file may not exist)

    - name: Check scan result
      if: ${{ steps.check-build.outputs.needs_build == 'true' && inputs.scan_vulnerabilities == 'true' && github.event_name != 'pull_request' }}
      shell: bash
      continue-on-error: true  # Security scan is advisory, not blocking
      run: |
        if [ "${{ steps.trivy-scan.outcome }}" = "failure" ]; then
          echo "::warning::Security scan found vulnerabilities above threshold"
          echo "::warning::Review the scan results above - this is advisory only"
        else
          echo "::notice::Security scan passed - no blocking vulnerabilities found"
        fi

    # GHCR Push - PRIMARY REGISTRY (required)
    # Push the already-built image with platform suffix for multi-arch manifest creation
    - name: Push to GHCR (primary)
      if: ${{ steps.check-build.outputs.needs_build == 'true' && github.event_name != 'pull_request' }}
      id: push-ghcr
      shell: bash
      run: |
        set -e
        image_name="${{ steps.check-build.outputs.image_name }}"
        current_tag="${{ steps.check-build.outputs.current_tag }}"
        platform_suffix="${{ steps.check-build.outputs.platform_suffix }}"

        # Source image (built without platform suffix)
        ghcr_image="ghcr.io/$image_name:$current_tag"
        # Target image with platform suffix for multi-arch manifest
        ghcr_image_platform="ghcr.io/$image_name:$current_tag-$platform_suffix"

        echo "::notice::Pushing pre-built image: $ghcr_image_platform"
        echo "::group::Pushing to GHCR (primary registry)"

        # Tag with platform suffix
        docker tag "$ghcr_image" "$ghcr_image_platform"

        if docker push "$ghcr_image_platform"; then
          echo "success=true" >> $GITHUB_OUTPUT
          echo "::notice::GHCR push successful for $ghcr_image_platform"
        else
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::error::GHCR push failed for $ghcr_image_platform"
          exit 1
        fi

        echo "::endgroup::"

    # Docker Hub Push - SECONDARY REGISTRY (optional, can fail)
    # Tag and push the already-built image with platform suffix
    - name: Push to Docker Hub (secondary)
      if: ${{ steps.check-build.outputs.needs_build == 'true' && github.event_name != 'pull_request' && steps.dockerhub-login.outcome == 'success' }}
      id: push-dockerhub
      shell: bash
      run: |
        image_name="${{ steps.check-build.outputs.image_name }}"
        current_tag="${{ steps.check-build.outputs.current_tag }}"
        platform_suffix="${{ steps.check-build.outputs.platform_suffix }}"

        ghcr_image="ghcr.io/$image_name:$current_tag"
        dockerhub_image="docker.io/$image_name:$current_tag-$platform_suffix"

        echo "::group::Pushing to Docker Hub (secondary registry)"

        # Tag the GHCR image for Docker Hub with platform suffix
        docker tag "$ghcr_image" "$dockerhub_image"

        if docker push "$dockerhub_image"; then
          echo "success=true" >> $GITHUB_OUTPUT
          echo "::notice::Docker Hub push successful for $dockerhub_image"
        else
          echo "success=false" >> $GITHUB_OUTPUT
          echo "::warning::Docker Hub push failed for $dockerhub_image - images available on GHCR only"
        fi

        echo "::endgroup::"
      continue-on-error: true

    - name: Skip push for pull request
      if: ${{ steps.check-build.outputs.needs_build == 'true' && github.event_name == 'pull_request' }}
      shell: bash
      run: |
        echo "::notice::Skipping push (pull request - test build only)"
