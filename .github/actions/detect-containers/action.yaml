name: 'Detect Containers to Build'
description: 'Detects which containers need building based on changes (GitHub handles path filtering)'

inputs:
  container:
    description: 'Specific container to build (overrides detection)'
    required: false
    default: ''
  force_rebuild:
    description: 'Force rebuild even if image exists'
    required: false
    default: 'false'

outputs:
  containers_list:
    description: 'Comma-separated list of containers that need building'
    value: ${{ steps.find-containers.outputs.containers_list }}
  containers:
    description: 'JSON array of containers that need building (converted from CSV for matrix compatibility)'
    value: ${{ steps.find-containers.outputs.containers }}
  count:
    description: 'Number of containers to build'
    value: ${{ steps.find-containers.outputs.count }}
  versions:
    description: 'JSON object mapping container names to their versions'
    value: ${{ steps.compute-versions.outputs.versions }}
  builds:
    description: 'JSON array of all builds needed (expanded variants)'
    value: ${{ steps.expand-variants.outputs.builds }}
  builds_count:
    description: 'Total number of builds (including variants)'
    value: ${{ steps.expand-variants.outputs.builds_count }}

runs:
  using: 'composite'
  steps:
    - name: Find containers to build
      id: find-containers
      shell: bash
      run: |
        set -e
        containers_to_build=()

        # Get list of valid containers from make script (source of truth)
        echo "ğŸ” Getting list of valid containers from make script..."
        valid_containers=$(cd "$GITHUB_WORKSPACE" && ./make list)
        
        if [[ -z "$valid_containers" ]]; then
          echo "âš ï¸  No valid containers found in make script"
          exit 1
        fi
        
        echo "ğŸ“‹ Valid containers from make: $(echo "$valid_containers" | tr '\n' ' ')"

        # If specific container requested, validate it
        if [ -n "${{ inputs.container }}" ]; then
          echo "ğŸ¯ Validating specific container: ${{ inputs.container }}"
          if echo "$valid_containers" | grep -qx "${{ inputs.container }}"; then
            containers_to_build=("${{ inputs.container }}")
            echo "âœ… Container validated"
          else
            echo "âŒ Container '${{ inputs.container }}' not found in make list"
            exit 1
          fi
        else
          echo "ğŸ” Detecting containers that need building based on changed files..."
          
          # Determine what files changed in this push/PR
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # For push events, use event SHAs (handles initial commit with all-zeros before SHA gracefully)
            if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
              # Initial commit - diff against empty tree
              # The SHA '4b825dc642cb6eb9a060e54bf8d69288fbee4904' is Git's canonical empty tree object hash, used for initial commit diffs.
              changed_files=$(git diff --name-only 4b825dc642cb6eb9a060e54bf8d69288fbee4904 "${{ github.event.after }}" 2>/dev/null) || { echo "âš ï¸ Git diff failed (initial commit)"; changed_files=""; }
            else
              changed_files=$(git diff --name-only "${{ github.event.before }}" "${{ github.event.after }}" 2>/dev/null) || { echo "âš ï¸ Git diff failed (push event)"; changed_files=""; }
            fi
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, compare with base and head SHAs from the event (robust, does not require fetch)
            changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} 2>/dev/null) || { echo "âš ï¸ Git diff failed (pull request event)"; changed_files=""; }
          else
            # For manual triggers or other events, no auto-detection
            changed_files=""
          fi

          if [[ -n "$changed_files" ]]; then
            echo "ğŸ“ Changed files:"
            echo "$changed_files"
            
            # Extract container names from changed file paths
            while IFS= read -r file; do
              # Skip root-level files (no slash in path)
              if [[ ! "$file" =~ / ]]; then
                continue
              fi
              
              # Extract the top-level directory from the file path
              container="${file%%/*}"
              
              # Skip if already processed
              if [[ " ${containers_to_build[*]} " =~ " ${container} " ]]; then
                continue
              fi
              
              # Verify container is in make's valid list (source of truth)
              if echo "$valid_containers" | grep -qx "$container"; then
                echo "ğŸ“¦ Container needs building: $container (changed files detected, validated by make)"
                containers_to_build+=("$container")
              fi
            done <<< "$changed_files"
          else
            echo "â„¹ï¸  No git diff available or manual trigger without specific container"
            echo "â„¹ï¸  Skipping auto-detection (use container input for manual builds)"
          fi
        fi

        # Create outputs (CSV first, then JSON for matrix compatibility)
        if [ ${#containers_to_build[@]} -eq 0 ]; then
          echo "containers_list=" >> $GITHUB_OUTPUT
          echo "containers=[]" >> $GITHUB_OUTPUT
          echo "count=0" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ No containers need building"
        else
          containers_csv=$(IFS=','; echo "${containers_to_build[*]}")
          container_json=$(printf '%s\n' "${containers_to_build[@]}" | jq -R . | jq -s -c .)
          echo "containers_list=$containers_csv" >> $GITHUB_OUTPUT
          echo "containers=$container_json" >> $GITHUB_OUTPUT
          echo "count=${#containers_to_build[@]}" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ Found containers to build: ${containers_to_build[*]}"
        fi

    - name: Compute versions for detected containers
      id: compute-versions
      if: steps.find-containers.outputs.count != '0'
      shell: bash
      run: |
        set -e
        containers_json='${{ steps.find-containers.outputs.containers }}'

        # Build a JSON object {container: version}
        versions_json="{}"

        for container in $(echo "$containers_json" | jq -r '.[]'); do
          echo "ğŸ” Getting version for $container..."
          version=$(./make version "$container" 2>/dev/null || echo "latest")
          if [[ -z "$version" || "$version" == "unknown" ]]; then
            version="latest"
          fi
          echo "  â†’ $container: $version"
          versions_json=$(echo "$versions_json" | jq -c --arg c "$container" --arg v "$version" '. + {($c): $v}')
        done

        # Output as single-line JSON (GitHub Actions requirement)
        versions_json=$(echo "$versions_json" | jq -c .)
        echo "versions=$versions_json" >> $GITHUB_OUTPUT
        echo "ğŸ“‹ Versions computed: $versions_json"

    - name: Expand variants for containers
      id: expand-variants
      if: steps.find-containers.outputs.count != '0'
      shell: bash
      run: |
        set -e
        containers_json='${{ steps.find-containers.outputs.containers }}'
        versions_json='${{ steps.compute-versions.outputs.versions }}'

        # Source variant utilities
        source ./helpers/variant-utils.sh

        # Build array of all builds needed
        builds_json="[]"
        builds_count=0

        for container in $(echo "$containers_json" | jq -r '.[]'); do
          version=$(echo "$versions_json" | jq -r --arg c "$container" '.[$c]')
          container_dir="./$container"

          if has_variants "$container_dir"; then
            echo "ğŸ“¦ Container $container has variants, expanding..."

            while IFS= read -r variant_name; do
              [[ -z "$variant_name" ]] && continue

              variant_tag=$(variant_image_tag "$version" "$variant_name" "$container_dir")
              flavor=$(variant_property "$container_dir" "$variant_name" "flavor")
              is_default=$(variant_property "$container_dir" "$variant_name" "default")

              # Add build entry
              builds_json=$(echo "$builds_json" | jq -c \
                --arg container "$container" \
                --arg version "$version" \
                --arg variant "$variant_name" \
                --arg tag "$variant_tag" \
                --arg flavor "$flavor" \
                --arg is_default "${is_default:-false}" \
                '. + [{container: $container, version: $version, variant: $variant, tag: $tag, flavor: $flavor, is_default: ($is_default == "true")}]')

              builds_count=$((builds_count + 1))
              echo "  â†’ Variant: $variant_name (tag: $variant_tag, flavor: $flavor)"
            done < <(list_variants "$container_dir")
          else
            # No variants - single build entry
            builds_json=$(echo "$builds_json" | jq -c \
              --arg container "$container" \
              --arg version "$version" \
              --arg tag "$version" \
              '. + [{container: $container, version: $version, variant: "", tag: $tag, flavor: "", is_default: true}]')

            builds_count=$((builds_count + 1))
            echo "ğŸ“¦ Container $container: single build (tag: $version)"
          fi
        done

        echo "builds=$builds_json" >> $GITHUB_OUTPUT
        echo "builds_count=$builds_count" >> $GITHUB_OUTPUT
        echo "ğŸ“‹ Total builds to perform: $builds_count"
        echo "$builds_json" | jq .
