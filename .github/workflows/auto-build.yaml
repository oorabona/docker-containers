name: Auto Build & Push

on:
  # Triggered by upstream-monitor workflow for version changes
  workflow_call:
    inputs:
      container:
        description: 'Specific container to build (leave empty for all)'
        required: false
        type: string
      force_rebuild:
        description: 'Force rebuild even if up-to-date'
        required: false
        default: false
        type: boolean
      skip_extensions:
        description: 'Skip extension compilation (use existing GHCR extension images)'
        required: false
        default: false
        type: boolean
      scope_versions:
        description: 'Comma-separated major versions to build (e.g., "18"). Empty = all.'
        required: false
        type: string
        default: ''
      scope_flavors:
        description: 'Comma-separated flavors to build (e.g., "distributed,full"). Empty = all.'
        required: false
        type: string
        default: ''
      scope_extensions:
        description: 'Comma-separated extensions to rebuild (e.g., "citus"). Empty = all.'
        required: false
        type: string
        default: ''
  # Triggered by container file changes (main automation via PR)
  pull_request:
    branches: [main, master]
    paths:
      - '*/Dockerfile'
      - '*/version.sh'
      - '*/config.yaml'
      - '*/docker-compose.yml'
      - '*/compose.yml'
      - '*/extensions/config.yaml'
      - 'helpers/extension-utils.sh'
      - 'make'
      - '!archive/**'  # Exclude archived containers
  # Triggered on merge to master (actual deployment)
  push:
    branches: [main, master]
    paths:
      - '*/Dockerfile'
      - '*/version.sh'
      - '*/config.yaml'
      - '*/docker-compose.yml'
      - '*/compose.yml'
      - '*/LAST_REBUILD.md'
      - '*/extensions/config.yaml'
      - 'helpers/extension-utils.sh'
      - 'make'
      - '!archive/**'  # Exclude archived containers
  # Manual trigger
  workflow_dispatch:
    inputs:
      container:
        description: 'Specific container to build (leave empty for all)'
        required: false
        type: string
      force_rebuild:
        description: 'Force rebuild even if no updates'
        required: false
        default: false
        type: boolean
      skip_extensions:
        description: 'Skip extension compilation (use existing GHCR extension images)'
        required: false
        default: false
        type: boolean
      scope_versions:
        description: 'Comma-separated major versions to build (e.g., "18"). Empty = all.'
        required: false
        type: string
        default: ''
      scope_flavors:
        description: 'Comma-separated flavors to build (e.g., "distributed,full"). Empty = all.'
        required: false
        type: string
        default: ''
      scope_extensions:
        description: 'Comma-separated extensions to rebuild (e.g., "citus"). Empty = all.'
        required: false
        type: string
        default: ''

permissions:
  contents: write
  packages: write
  pages: write
  id-token: write
  attestations: write  # Required for GitHub SBOM attestations (actions/attest-sbom)
  # pull-requests: write ‚Äî removed: lineage now cached, no longer creating PRs
  security-events: write  # Required for uploading SARIF to GitHub Security

jobs:
  detect-containers:
    runs-on: ubuntu-latest
    outputs:
      containers: ${{ steps.detect.outputs.containers }}
      count: ${{ steps.detect.outputs.count }}
      versions: ${{ steps.detect.outputs.versions }}
      builds: ${{ steps.detect.outputs.builds }}
      builds_count: ${{ steps.detect.outputs.builds_count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 0

      - name: Install yq for variant detection
        uses: mikefarah/yq@5a7e72a743649b1b3a47d1a1d8214f3453173c51 # v4.52.4
        with:
          cmd: yq --version

      - name: Detect containers to build
        id: detect
        uses: ./.github/actions/detect-containers
        with:
          container: ${{ github.event.inputs.container || inputs.container }}
          force_rebuild: ${{ github.event.inputs.force_rebuild || inputs.force_rebuild }}
          scope_versions: ${{ github.event.inputs.scope_versions || inputs.scope_versions }}
          scope_flavors: ${{ github.event.inputs.scope_flavors || inputs.scope_flavors }}

  # Build and push PostgreSQL extension images if postgres is in the build list
  build-extensions:
    name: Build PostgreSQL Extensions
    needs: [detect-containers]
    if: |
      needs.detect-containers.outputs.count > 0 &&
      contains(needs.detect-containers.outputs.containers, 'postgres') &&
      (github.event.inputs.skip_extensions || inputs.skip_extensions) != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Log in to container registries
        uses: ./.github/actions/docker-login
        with:
          ghcr_username: ${{ github.actor }}
          ghcr_password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get versions requiring extensions
        id: ext-versions
        run: |
          source ./helpers/variant-utils.sh

          # Find containers that require extensions (have requires_extensions: true in variants.yaml)
          containers_with_extensions=""
          versions_by_container=""

          for container_dir in */; do
            container="${container_dir%/}"
            [[ ! -f "$container_dir/variants.yaml" ]] && continue

            if requires_extensions "./$container"; then
              echo "üì¶ Container $container requires extensions"
              containers_with_extensions="$containers_with_extensions $container"

              # Get versions that have non-base variants
              versions_needing_extensions=""
              while IFS= read -r major_version; do
                [[ -z "$major_version" ]] && continue

                has_extension_variants=false
                while IFS= read -r variant; do
                  [[ -z "$variant" ]] && continue
                  flavor=$(variant_property "./$container" "$variant" "flavor" "$major_version")
                  if [[ "$flavor" != "base" ]]; then
                    has_extension_variants=true
                    break
                  fi
                done < <(list_variants "./$container" "$major_version")

                if [[ "$has_extension_variants" == "true" ]]; then
                  versions_needing_extensions="$versions_needing_extensions $major_version"
                  echo "  ‚Üí v$major_version needs extensions"
                fi
              done < <(list_versions "./$container")

              versions_by_container="$versions_by_container|$container:$(echo $versions_needing_extensions | xargs | tr ' ' ',')"
            fi
          done

          # Output results
          containers_with_extensions=$(echo "$containers_with_extensions" | xargs)
          echo "containers=$containers_with_extensions" >> $GITHUB_OUTPUT
          echo "versions_map=${versions_by_container#|}" >> $GITHUB_OUTPUT
          echo "üìã Containers with extensions: $containers_with_extensions"

      - name: Build and push extension images
        if: steps.ext-versions.outputs.containers != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SCOPE_VERSIONS: ${{ github.event.inputs.scope_versions || inputs.scope_versions }}
          SCOPE_EXTENSIONS: ${{ github.event.inputs.scope_extensions || inputs.scope_extensions }}
        run: |
          chmod +x scripts/build-extensions.sh helpers/extension-utils.sh

          # Parse versions map and build for each container/version
          IFS='|' read -ra ENTRIES <<< "${{ steps.ext-versions.outputs.versions_map }}"
          for entry in "${ENTRIES[@]}"; do
            [[ -z "$entry" ]] && continue
            container="${entry%%:*}"
            versions="${entry#*:}"

            IFS=',' read -ra VERSION_LIST <<< "$versions"
            for major_version in "${VERSION_LIST[@]}"; do
              [[ -z "$major_version" ]] && continue

              # Skip versions not in scope (if scope_versions is set)
              if [[ -n "$SCOPE_VERSIONS" ]]; then
                if ! echo ",$SCOPE_VERSIONS," | grep -q ",$major_version,"; then
                  echo "‚è≠Ô∏è Skipping extensions for $container v$major_version (not in scope: $SCOPE_VERSIONS)"
                  continue
                fi
              fi

              # Build specific extensions or all
              if [[ -n "$SCOPE_EXTENSIONS" ]]; then
                echo "üîß Building scoped extensions ($SCOPE_EXTENSIONS) for $container v$major_version..."
                IFS=',' read -ra EXT_LIST <<< "$SCOPE_EXTENSIONS"
                for ext in "${EXT_LIST[@]}"; do
                  [[ -z "$ext" ]] && continue
                  ./scripts/build-extensions.sh "$container" --major-version "$major_version" --extension "$ext"
                done
              else
                echo "üîß Building all extensions for $container v$major_version..."
                ./scripts/build-extensions.sh "$container" --major-version "$major_version"
              fi
            done
          done

  # Cache Docker Hub base images to GHCR to avoid rate limits during builds
  cache-base-images:
    name: Cache base images
    needs: [detect-containers]
    if: |
      needs.detect-containers.outputs.count > 0 &&
      github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Install yq
        uses: mikefarah/yq@5a7e72a743649b1b3a47d1a1d8214f3453173c51 # v4.52.4
        with:
          cmd: yq --version

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect and cache base images
        env:
          OWNER: ${{ github.repository_owner }}
          CONTAINERS: ${{ needs.detect-containers.outputs.containers }}
          VERSIONS: ${{ needs.detect-containers.outputs.versions }}
        run: |
          set -euo pipefail
          source ./helpers/base-cache-utils.sh

          echo "üì¶ Collecting base images to cache..."
          images=$(collect_all_cache_images "$CONTAINERS" "$VERSIONS" "$OWNER")
          count=$(echo "$images" | jq 'length')
          echo "Found $count unique base images to cache (deduplicated)"

          if [[ "$count" -eq 0 ]]; then
            echo "No base images to cache"
            exit 0
          fi

          # Copy each base image from Docker Hub to GHCR
          cached=0
          failed=0
          echo "$images" | jq -c '.[]' | while IFS= read -r img; do
            source_img=$(echo "$img" | jq -r '.source')
            tag=$(echo "$img" | jq -r '.tag')
            ghcr_image=$(echo "$img" | jq -r '.ghcr_image')

            echo ""
            echo "üîÑ Caching $source_img:$tag ‚Üí $ghcr_image"

            if docker buildx imagetools create \
              --tag "$ghcr_image" \
              "docker.io/$source_img:$tag" 2>/dev/null; then
              echo "  ‚úÖ Cached successfully"
            else
              echo "  ‚ö†Ô∏è Failed to cache (Docker Hub rate limit?), build will use existing cache or fall back to Docker Hub"
            fi
          done

          echo ""
          echo "‚úÖ Base image caching complete"

  build-and-push:
    name: Build ${{ matrix.build.container }}${{ matrix.build.variant && format(':{0}', matrix.build.variant) || '' }} (${{ matrix.arch }})
    needs: [detect-containers, build-extensions, cache-base-images]
    if: |
      always() &&
      needs.detect-containers.outputs.builds_count > 0 &&
      (needs.build-extensions.result == 'success' || needs.build-extensions.result == 'skipped') &&
      (needs.cache-base-images.result == 'success' || needs.cache-base-images.result == 'skipped')
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      max-parallel: 4  # Allow more parallel builds since we're splitting by platform
      matrix:
        build: ${{ fromJson(needs.detect-containers.outputs.builds) }}
        arch: [amd64, arm64]
        include:
          - arch: amd64
            platform: linux/amd64
            runner: ubuntu-latest
          - arch: arm64
            platform: linux/arm64
            runner: ubuntu-24.04-arm

    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Install yq (needed for extension Dockerfile generation)
        uses: mikefarah/yq@5a7e72a743649b1b3a47d1a1d8214f3453173c51 # v4.52.4
        with:
          cmd: yq --version

      - name: Build container with retry logic
        id: build
        uses: ./.github/actions/build-container
        with:
          container: ${{ matrix.build.container }}
          version: ${{ matrix.build.version }}
          tag: ${{ matrix.build.tag }}
          flavor: ${{ matrix.build.flavor }}
          variant: ${{ matrix.build.variant }}
          dockerfile: ${{ matrix.build.dockerfile }}
          platform: ${{ matrix.platform }}
          force_rebuild: ${{ github.event.inputs.force_rebuild }}
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Retry build on failure
        if: steps.build.outcome == 'failure'
        id: retry
        uses: ./.github/actions/build-container
        with:
          container: ${{ matrix.build.container }}
          version: ${{ matrix.build.version }}
          tag: ${{ matrix.build.tag }}
          flavor: ${{ matrix.build.flavor }}
          variant: ${{ matrix.build.variant }}
          dockerfile: ${{ matrix.build.dockerfile }}
          platform: ${{ matrix.platform }}
          force_rebuild: true  # Force rebuild on retry
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Handle build failure
        if: steps.build.outcome == 'failure' && steps.retry.outcome == 'failure'
        run: |
          container="${{ matrix.build.container }}"
          variant="${{ matrix.build.variant }}"
          tag="${{ matrix.build.tag }}"
          display_name="$container${variant:+:$variant}"

          echo "‚ùå Build failed for $display_name after retry"
          echo "## üö® Build Failed: $display_name" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Container:** \`$container\`" >> $GITHUB_STEP_SUMMARY
          [[ -n "$variant" ]] && echo "**Variant:** \`$variant\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`$tag\`" >> $GITHUB_STEP_SUMMARY
          echo "**Attempt:** Initial build + 1 retry" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ‚ùå Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Possible causes:**" >> $GITHUB_STEP_SUMMARY
          echo "- Network connectivity issues" >> $GITHUB_STEP_SUMMARY
          echo "- Upstream dependency changes" >> $GITHUB_STEP_SUMMARY
          echo "- Dockerfile syntax errors" >> $GITHUB_STEP_SUMMARY
          echo "- Registry authentication issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the build logs above for detailed error messages" >> $GITHUB_STEP_SUMMARY
          echo "2. Test the build locally: \`./make build $container\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Check if the container's version.sh script is working" >> $GITHUB_STEP_SUMMARY
          exit 1

      - name: Report successful build
        if: steps.build.outcome == 'success' || steps.retry.outcome == 'success'
        run: |
          container="${{ matrix.build.container }}"
          variant="${{ matrix.build.variant }}"
          tag="${{ matrix.build.tag }}"
          display_name="$container${variant:+:$variant}"

          attempt="first attempt"
          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            attempt="retry attempt"
          fi
          echo "‚úÖ Build succeeded for $display_name on $attempt"
          echo "## ‚úÖ Build Successful: $display_name" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Container:** \`$container\`" >> $GITHUB_STEP_SUMMARY
          [[ -n "$variant" ]] && echo "**Variant:** \`$variant\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`$tag\`" >> $GITHUB_STEP_SUMMARY
          echo "**Attempt:** $attempt" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ‚úÖ Success" >> $GITHUB_STEP_SUMMARY

      - name: Generate build summary
        if: always()
        run: |
          container="${{ matrix.build.container }}"
          variant="${{ matrix.build.variant }}"
          tag="${{ matrix.build.tag }}"
          needs_build="${{ steps.build.outputs.built }}"
          current_tag="${{ steps.build.outputs.tag }}"
          display_name="$container${variant:+:$variant}"

          # Construct image names to avoid secret masking
          github_username="${{ github.repository_owner }}"
          dockerhub_username="${{ secrets.DOCKERHUB_USERNAME }}"

          echo "## üì¶ Build Summary for \`$display_name\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Container** | \`$container\` |" >> $GITHUB_STEP_SUMMARY
          [[ -n "$variant" ]] && echo "| **Variant** | \`$variant\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | \`$current_tag\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | \`${{ github.event_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Build Needed** | \`$needs_build\` |" >> $GITHUB_STEP_SUMMARY

          if [ "$needs_build" = "true" ]; then
            echo "| **GHCR Image** | \`ghcr.io/${github_username}/${container}:$current_tag\` |" >> $GITHUB_STEP_SUMMARY
            if [ -n "$dockerhub_username" ]; then
              echo "| **Docker Hub Image** | \`docker.io/${dockerhub_username}/${container}:$current_tag\` |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ‚úÖ Successfully built and pushed!" >> $GITHUB_STEP_SUMMARY

            echo "**üéØ Smart Detection Results:**" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "- üìù **Trigger**: Code changes detected in container files" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ github.event.inputs.force_rebuild || inputs.force_rebuild }}" = "true" ]; then
              echo "- üîÑ **Trigger**: Force rebuild requested" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ github.event_name }}" = "workflow_call" ]; then
              echo "- üîÑ **Trigger**: Upstream version changes detected" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üîç **Trigger**: Manual workflow dispatch" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ‚è≠Ô∏è Build skipped" >> $GITHUB_STEP_SUMMARY

            echo "**üéØ Smart Detection Results:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Images already exist in all target registries" >> $GITHUB_STEP_SUMMARY
            echo "- üìã Tag \`$current_tag\` is up to date" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Upload build lineage
        if: (steps.build.outcome == 'success' || steps.retry.outcome == 'success') && matrix.arch == 'amd64'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: build-lineage-${{ matrix.build.container }}-${{ matrix.build.tag }}
          path: .build-lineage/${{ matrix.build.container }}-${{ matrix.build.tag }}.json
          if-no-files-found: warn
          include-hidden-files: true
          retention-days: 1

      # SBOM generation (amd64 only ‚Äî packages are identical across arches)
      - name: Install syft
        id: install-syft
        if: (steps.build.outcome == 'success' || steps.retry.outcome == 'success') && matrix.arch == 'amd64' && github.event_name != 'pull_request'
        uses: anchore/sbom-action/download-syft@28d71544de8eaf1b958d335707167c5f783590ad # v0.22.2

      - name: Generate SBOM
        id: sbom
        if: steps.install-syft.outcome == 'success'
        env:
          CONTAINER: ${{ matrix.build.container }}
          TAG: ${{ matrix.build.tag }}
          GITHUB_USERNAME: ${{ github.repository_owner }}
        run: |
          source ./helpers/sbom-utils.sh
          image_ref="ghcr.io/${GITHUB_USERNAME}/${CONTAINER}:${TAG}-amd64"
          sbom_file=".build-lineage/${CONTAINER}-${TAG}.sbom.json"
          generate_sbom "$image_ref" "$sbom_file"
          echo "sbom_file=$sbom_file" >> "$GITHUB_OUTPUT"

          # Capture digest for attestation (from local image after push)
          digest=$(docker inspect --format='{{range .RepoDigests}}{{.}}{{end}}' "$image_ref" 2>/dev/null | head -1 | sed 's/.*@//' || echo "")
          if [[ -z "$digest" ]]; then
            # Fallback: query registry
            digest=$(docker buildx imagetools inspect "$image_ref" --raw 2>/dev/null | sha256sum | awk '{print "sha256:"$1}' || echo "")
          fi
          echo "digest=$digest" >> "$GITHUB_OUTPUT"
        continue-on-error: true

      - name: Upload SBOM artifact
        if: steps.sbom.outcome == 'success'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v4
        with:
          name: sbom-${{ matrix.build.container }}-${{ matrix.build.tag }}
          path: ${{ steps.sbom.outputs.sbom_file }}
          if-no-files-found: warn
          include-hidden-files: true
          retention-days: 1

      - name: Attest SBOM
        if: steps.sbom.outcome == 'success' && steps.sbom.outputs.digest != ''
        uses: actions/attest-sbom@10926c72720ffc3f7b666661c8e55b1344e2a365 # v2
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/${{ matrix.build.container }}
          subject-digest: ${{ steps.sbom.outputs.digest }}
          sbom-path: ${{ steps.sbom.outputs.sbom_file }}
        continue-on-error: true

  create-manifest:
    name: Create Manifest ${{ matrix.build.container }}:${{ matrix.build.tag }}
    needs: [detect-containers, build-and-push]
    if: |
      always() &&
      needs.build-and-push.result == 'success' &&
      needs.detect-containers.outputs.builds_count > 0 &&
      github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        build: ${{ fromJson(needs.detect-containers.outputs.builds) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Log in to container registries
        uses: ./.github/actions/docker-login
        with:
          ghcr_username: ${{ github.actor }}
          ghcr_password: ${{ secrets.GITHUB_TOKEN }}
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}

      # GHCR Manifest - PRIMARY (required)
      - name: Create GHCR multi-arch manifest (primary)
        id: ghcr-manifest
        env:
          CONTAINER: ${{ matrix.build.container }}
          TAG: ${{ matrix.build.tag }}
          VERSION: ${{ matrix.build.version }}
          FULL_VERSION: ${{ matrix.build.full_version }}
          VARIANT: ${{ matrix.build.variant }}
          IS_DEFAULT: ${{ matrix.build.is_default }}
          IS_LATEST_VERSION: ${{ matrix.build.is_latest_version }}
          GITHUB_USERNAME: ${{ github.repository_owner }}
        run: |
          set -e
          ghcr_image="ghcr.io/$GITHUB_USERNAME/$CONTAINER"

          echo "::group::Creating GHCR manifest for $CONTAINER:$TAG"

          # Build tag arguments - version tag is always included (rolling, e.g., 18-alpine)
          tag_args="-t $ghcr_image:$TAG"

          # Version-specific tag (e.g., 18.2-alpine alongside rolling 18-alpine)
          # Enables dashboard version tracking via registry pattern matching
          if [[ -n "$FULL_VERSION" && "$FULL_VERSION" != "$TAG" ]]; then
            rest="${TAG#$VERSION}"
            full_numeric=$(echo "$FULL_VERSION" | grep -oP '^[0-9]+\.[0-9]+(\.[0-9]+)?')
            if [[ -n "$full_numeric" ]]; then
              full_tag="${full_numeric}${rest}"
              if [[ "$full_tag" != "$TAG" ]]; then
                tag_args="$tag_args -t $ghcr_image:$full_tag"
                echo "::notice::Adding version-specific tag: $full_tag"
              fi
            fi
          fi

          # Rolling tags only for the latest version (e.g., PG 18 but not PG 17/16)
          # Add :latest tag for default variant of the latest version
          if [[ "$IS_DEFAULT" == "true" && "$IS_LATEST_VERSION" == "true" ]]; then
            tag_args="$tag_args -t $ghcr_image:latest"
            echo "::notice::This is the default variant of latest version - will also tag as :latest"
          fi

          # Add :latest-{variant} tag for non-default variants of the latest version
          if [[ -n "$VARIANT" && "$IS_DEFAULT" != "true" && "$IS_LATEST_VERSION" == "true" ]]; then
            tag_args="$tag_args -t $ghcr_image:latest-$VARIANT"
            echo "::notice::Adding rolling tag: latest-$VARIANT"
          fi

          # Try multi-arch manifest first
          if docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-amd64" \
            "$ghcr_image:$TAG-arm64" 2>/dev/null; then
            echo "::notice::GHCR multi-arch manifest created successfully"
          # Fallback to single platform
          elif docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-amd64" 2>/dev/null; then
            echo "::warning::GHCR manifest created with amd64 only (arm64 not available)"
          elif docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-arm64" 2>/dev/null; then
            echo "::warning::GHCR manifest created with arm64 only (amd64 not available)"
          else
            echo "::error::No platform-specific images found for GHCR"
            exit 1
          fi

          echo "::endgroup::"

      # Docker Hub Manifest - SECONDARY (optional, can fail)
      # Uses GHCR images as sources (cross-registry) since reading Docker Hub
      # arch-specific tags with imagetools can fail without a buildx builder
      - name: Create Docker Hub multi-arch manifest (secondary)
        env:
          CONTAINER: ${{ matrix.build.container }}
          TAG: ${{ matrix.build.tag }}
          VERSION: ${{ matrix.build.version }}
          FULL_VERSION: ${{ matrix.build.full_version }}
          VARIANT: ${{ matrix.build.variant }}
          IS_DEFAULT: ${{ matrix.build.is_default }}
          IS_LATEST_VERSION: ${{ matrix.build.is_latest_version }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          GITHUB_USERNAME: ${{ github.repository_owner }}
        run: |
          # Skip if no Docker Hub credentials
          if [[ -z "$DOCKERHUB_USERNAME" ]]; then
            echo "::notice::Skipping Docker Hub manifest (no credentials)"
            exit 0
          fi

          dockerhub_image="docker.io/$DOCKERHUB_USERNAME/$CONTAINER"
          ghcr_image="ghcr.io/$GITHUB_USERNAME/$CONTAINER"

          echo "::group::Creating Docker Hub manifest for $CONTAINER:$TAG"

          # Build tag arguments - version tag is always included (rolling, e.g., 18-alpine)
          tag_args="-t $dockerhub_image:$TAG"

          # Version-specific tag (e.g., 18.2-alpine alongside rolling 18-alpine)
          if [[ -n "$FULL_VERSION" && "$FULL_VERSION" != "$TAG" ]]; then
            rest="${TAG#$VERSION}"
            full_numeric=$(echo "$FULL_VERSION" | grep -oP '^[0-9]+\.[0-9]+(\.[0-9]+)?')
            if [[ -n "$full_numeric" ]]; then
              full_tag="${full_numeric}${rest}"
              if [[ "$full_tag" != "$TAG" ]]; then
                tag_args="$tag_args -t $dockerhub_image:$full_tag"
                echo "::notice::Adding version-specific tag: $full_tag"
              fi
            fi
          fi

          # Rolling tags only for the latest version
          if [[ "$IS_DEFAULT" == "true" && "$IS_LATEST_VERSION" == "true" ]]; then
            tag_args="$tag_args -t $dockerhub_image:latest"
          fi

          if [[ -n "$VARIANT" && "$IS_DEFAULT" != "true" && "$IS_LATEST_VERSION" == "true" ]]; then
            tag_args="$tag_args -t $dockerhub_image:latest-$VARIANT"
          fi

          # Use GHCR images as sources (cross-registry copy) ‚Äî more reliable than
          # reading back from Docker Hub which can fail without buildx builder setup
          if docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-amd64" \
            "$ghcr_image:$TAG-arm64"; then
            echo "::notice::Docker Hub multi-arch manifest created successfully (from GHCR sources)"
          # Fallback to single platform
          elif docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-amd64"; then
            echo "::warning::Docker Hub manifest created with amd64 only"
          elif docker buildx imagetools create $tag_args \
            "$ghcr_image:$TAG-arm64"; then
            echo "::warning::Docker Hub manifest created with arm64 only"
          else
            echo "::warning::Docker Hub manifest creation failed - images available on GHCR only"
          fi

          echo "::endgroup::"
        continue-on-error: true

  summary:
    needs: [detect-containers, build-and-push, create-manifest]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate workflow summary
        id: summary
        run: |
          echo "# üöÄ Auto Build & Push - Workflow Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger** | \`${{ github.event_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | \`${{ github.repository }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch/Ref** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY

          containers='${{ needs.detect-containers.outputs.containers }}'
          container_count='${{ needs.detect-containers.outputs.count }}'

          if [ "$container_count" -gt 0 ]; then
            echo "| **Containers Processed** | $container_count |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| **Containers Processed** | 0 |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$container_count" -eq 0 ]; then
            echo "### ‚ÑπÔ∏è No containers needed building" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üéØ Smart Detection Results:**" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "- üìù No container files were modified in this commit" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ github.event_name }}" = "workflow_call" ]; then
              echo "- ‚úÖ No containers needed building from workflow call" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ‚úÖ All container images are up to date in registries" >> $GITHUB_STEP_SUMMARY
              echo "- üîç No new upstream versions detected" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${{ needs.build-and-push.result }}" = "success" ]; then
            echo "### ‚úÖ All builds completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üéØ Smart Detection Features:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Automatic triggering** on container file changes" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Upstream version monitoring** for automatic updates" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Registry verification** to avoid duplicate builds" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Native multi-platform** builds (amd64 + arm64 on native runners)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Multi-registry** publishing (GHCR + Docker Hub)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚è∏Ô∏è **Security scanning** (temporarily disabled)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build-and-push.result }}" = "skipped" ]; then
            echo "### ‚è≠Ô∏è Builds were skipped" >> $GITHUB_STEP_SUMMARY
            echo "All target images already exist and are up to date." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Some builds failed or were cancelled" >> $GITHUB_STEP_SUMMARY
            echo "Check the individual job logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "build_failed=true" >> $GITHUB_OUTPUT
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_ü§ñ Smart CI/CD powered by GitHub Actions_" >> $GITHUB_STEP_SUMMARY

      - name: Create issue on build failure
        if: steps.summary.outputs.build_failed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if similar issue already exists (open, same run)
          existing=$(gh issue list --label "build-failure" --state open --limit 5 --json title,number \
            | jq -r '.[] | select(.title | contains("Auto Build Failed")) | .number' | head -1)

          if [[ -n "$existing" ]]; then
            echo "‚ÑπÔ∏è Adding comment to existing issue #$existing"
            gh issue comment "$existing" --body "$(cat <<EOF
          ## üîÑ Another build failure detected

          **Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          **Trigger:** \`${{ github.event_name }}\`
          **Ref:** \`${{ github.ref_name }}\`
          **Time:** $(date -u +"%Y-%m-%d %H:%M UTC")
          EOF
          )"
          else
            echo "üö® Creating new build failure issue"
            gh issue create \
              --title "üö® Auto Build Failed - $(date -u +%Y-%m-%d)" \
              --label "build-failure,automation" \
              --body "$(cat <<EOF
          ## Build Failure Alert

          One or more container builds failed in the auto-build workflow.

          | Property | Value |
          |----------|-------|
          | **Run** | [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          | **Trigger** | \`${{ github.event_name }}\` |
          | **Ref** | \`${{ github.ref_name }}\` |
          | **Commit** | \`${{ github.sha }}\` |

          ## Next Steps

          1. Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details
          2. Identify which container(s) failed
          3. Test locally: \`./make build <container>\`
          4. Fix and push to trigger rebuild

          ---
          _Auto-generated by CI workflow_
          EOF
          )"
          fi

  cache-lineage:
    name: Cache build lineage
    needs: [build-and-push, create-manifest]
    # Run on partial failure: successful builds still have lineage to cache
    if: |
      always() &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'failure') &&
      (needs.create-manifest.result == 'success' || needs.create-manifest.result == 'skipped' || needs.create-manifest.result == 'failure') &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          sparse-checkout: helpers

      - name: Restore previous lineage cache
        uses: actions/cache/restore@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
        with:
          path: .build-lineage
          key: build-lineage-${{ github.run_id }}
          restore-keys: build-lineage-

      - name: Download current build artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v4
        with:
          pattern: build-lineage-*
          path: .build-lineage-artifacts/
          merge-multiple: false

      - name: Merge lineage files
        id: merge
        run: |
          mkdir -p .build-lineage
          if [ -d ".build-lineage-artifacts" ]; then
            find .build-lineage-artifacts -name '*.json' -exec cp {} .build-lineage/ \;
            count=$(find .build-lineage -name '*.json' | wc -l)
            echo "Consolidated $count lineage files"
            echo "has_files=true" >> "$GITHUB_OUTPUT"
          else
            echo "No lineage artifacts found"
            echo "has_files=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Download SBOM artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v4
        with:
          pattern: sbom-*
          path: .build-lineage-sbom-artifacts/
          merge-multiple: false
        continue-on-error: true

      - name: Process SBOMs (compare + history)
        run: |
          source helpers/sbom-utils.sh

          if [[ ! -d ".build-lineage-sbom-artifacts" ]]; then
            echo "No SBOM artifacts found ‚Äî skipping processing"
            exit 0
          fi

          for new_sbom_dir in .build-lineage-sbom-artifacts/*/; do
            [[ -d "$new_sbom_dir" ]] || continue
            sbom_file=$(find "$new_sbom_dir" -name '*.sbom.json' -print -quit)
            [[ -z "$sbom_file" ]] && continue

            basename=$(basename "$sbom_file")
            container_tag="${basename%.sbom.json}"

            echo "::group::Processing SBOM for $container_tag"

            # Compare with previously cached SBOM (if exists)
            cached_sbom=".build-lineage/${basename}"
            if [[ -f "$cached_sbom" ]]; then
              compare_sboms "$sbom_file" "$cached_sbom" \
                ".build-lineage/${container_tag}.changelog.json" || true
            else
              echo "No previous SBOM for $container_tag ‚Äî first build"
            fi

            # Extract summary and append to build history
            summary=$(extract_sbom_summary "$sbom_file")
            lineage_file=".build-lineage/${container_tag}.json"
            append_build_history "$lineage_file" "$summary" \
              ".build-lineage/${container_tag}.history.json" || true

            # Replace cached SBOM with new one
            cp "$sbom_file" "$cached_sbom"

            echo "::endgroup::"
          done

      - name: Save consolidated lineage cache
        if: steps.merge.outputs.has_files == 'true'
        uses: actions/cache/save@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
        with:
          path: .build-lineage
          key: build-lineage-${{ github.run_id }}

  update-dashboard:
    needs: [detect-containers, build-and-push, create-manifest, cache-lineage]
    # Update dashboard after builds (even partial failures) on master
    # Dashboard will show warnings for failed/missing builds
    if: |
      always() &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'failure') &&
      (needs.create-manifest.result == 'success' || needs.create-manifest.result == 'skipped' || needs.create-manifest.result == 'failure') &&
      (needs.cache-lineage.result == 'success' || needs.cache-lineage.result == 'skipped') &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      github.ref == 'refs/heads/master'
    uses: ./.github/workflows/update-dashboard.yaml
    with:
      trigger_reason: "Post-build dashboard update"
    secrets: inherit
# Permissions are required for updating version files, committing changes, and publishing packages during the auto-build process.
