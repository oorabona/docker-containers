name: Cleanup GHCR Registry

on:
  schedule:
    # Run monthly on the 1st at 3:00 AM UTC
    - cron: '0 3 1 * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (no deletions)'
        required: false
        type: boolean
        default: false
      purge_obsolete:
        description: 'Purge images with tags not matching current valid builds'
        required: false
        type: boolean
        default: false
      container_filter:
        description: 'Only process this container (optional, for targeted cleanup)'
        required: false
        type: string
        default: ''

permissions:
  packages: write

env:
  # Retention settings
  KEEP_LATEST_COUNT: 10
  KEEP_MONTHS: 6

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Cleanup old versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
          OWNER: ${{ github.repository_owner }}
        run: |
          set -euo pipefail

          CUTOFF_DATE=$(date -d "-${KEEP_MONTHS} months" +%Y-%m-%dT%H:%M:%SZ)

          echo "========================================"
          echo "GHCR Cleanup Configuration"
          echo "========================================"
          echo "Owner: $OWNER"
          echo "Keep latest count: $KEEP_LATEST_COUNT"
          echo "Keep versions newer than: $CUTOFF_DATE"
          echo "Dry run: $DRY_RUN"
          echo "========================================"

          # Get list of containers from repo
          CONTAINERS=$(find . -maxdepth 2 -name "Dockerfile" -exec dirname {} \; | sed 's|^\./||' | sort)

          TOTAL_DELETED=0
          TOTAL_KEPT=0

          for CONTAINER in $CONTAINERS; do
            echo ""
            echo "========================================"
            echo "Processing: $CONTAINER"
            echo "========================================"

            # Get all versions for this package
            VERSIONS=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/users/${OWNER}/packages/container/${CONTAINER}/versions" \
              --paginate 2>/dev/null || echo "[]")

            if [ "$VERSIONS" = "[]" ] || [ -z "$VERSIONS" ]; then
              echo "  No versions found (might be new or private)"
              continue
            fi

            # Count versions
            VERSION_COUNT=$(echo "$VERSIONS" | jq 'length')
            echo "  Found $VERSION_COUNT versions"

            # Save versions to temp file to avoid subshell issues
            VERSIONS_FILE=$(mktemp)
            echo "$VERSIONS" | jq -r '.[] | "\(.id)|\(.metadata.container.tags // [] | join(","))|\(.created_at)"' > "$VERSIONS_FILE"

            # Track major versions seen (to keep latest of each)
            declare -A MAJOR_SEEN=()
            POSITION=0
            KEPT=0
            DELETED=0

            # Process versions (API returns newest first)
            while IFS='|' read -r VERSION_ID TAGS CREATED_AT; do
              POSITION=$((POSITION + 1))

              # Skip if no version ID
              [ -z "$VERSION_ID" ] && continue

              KEEP_REASON=""

              # Rule 1: Keep "latest" tag
              if echo ",$TAGS," | grep -q ",latest,"; then
                KEEP_REASON="has 'latest' tag"
              fi

              # Rule 2: Keep top N most recent
              if [ -z "$KEEP_REASON" ] && [ "$POSITION" -le "$KEEP_LATEST_COUNT" ]; then
                KEEP_REASON="in top $KEEP_LATEST_COUNT recent"
              fi

              # Rule 3: Check if latest of a major version
              if [ -z "$KEEP_REASON" ]; then
                for TAG in $(echo "$TAGS" | tr ',' ' '); do
                  if [[ "$TAG" =~ ^v?([0-9]+)\.[0-9] ]]; then
                    MAJOR="${BASH_REMATCH[1]}"
                    if [ -z "${MAJOR_SEEN[$MAJOR]:-}" ]; then
                      MAJOR_SEEN[$MAJOR]=1
                      KEEP_REASON="latest of major v$MAJOR"
                    fi
                    break
                  fi
                done
              fi

              # Rule 4: Keep if newer than cutoff
              if [ -z "$KEEP_REASON" ]; then
                VERSION_TS=$(date -d "$CREATED_AT" +%s 2>/dev/null || echo "0")
                CUTOFF_TS=$(date -d "$CUTOFF_DATE" +%s)
                if [ "$VERSION_TS" -gt "$CUTOFF_TS" ]; then
                  KEEP_REASON="newer than $KEEP_MONTHS months"
                fi
              fi

              # Decision
              if [ -n "$KEEP_REASON" ]; then
                echo "  ✓ Keep #$POSITION (tags: ${TAGS:-untagged}) - $KEEP_REASON"
                KEPT=$((KEPT + 1))
              else
                echo "  ✗ Delete #$POSITION (tags: ${TAGS:-untagged}, created: $CREATED_AT)"
                if [ "$DRY_RUN" = "true" ]; then
                  echo "    [DRY RUN] Would delete version $VERSION_ID"
                else
                  if gh api \
                    --method DELETE \
                    -H "Accept: application/vnd.github+json" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "/users/${OWNER}/packages/container/${CONTAINER}/versions/${VERSION_ID}" 2>/dev/null; then
                    echo "    ✓ Deleted"
                    DELETED=$((DELETED + 1))
                  else
                    echo "    ✗ Failed to delete"
                  fi
                fi
              fi
            done < "$VERSIONS_FILE"

            rm -f "$VERSIONS_FILE"
            TOTAL_KEPT=$((TOTAL_KEPT + KEPT))
            TOTAL_DELETED=$((TOTAL_DELETED + DELETED))
            echo "  Summary: kept=$KEPT, deleted=$DELETED"
          done

          echo ""
          echo "========================================"
          echo "Cleanup Summary"
          echo "========================================"
          echo "Versions kept: $TOTAL_KEPT"
          echo "Versions deleted: $TOTAL_DELETED"
          echo "========================================"

      - name: Install yq
        if: github.event_name == 'schedule' || inputs.purge_obsolete == true
        uses: mikefarah/yq@2be0094729a1006f61e8339ce9934bfb3cbb549f # v4.52.2
        with:
          cmd: yq --version

      - name: Purge obsolete images
        if: github.event_name == 'schedule' || inputs.purge_obsolete == true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ inputs.dry_run || 'false' }}
          OWNER: ${{ github.repository_owner }}
          CONTAINER_FILTER: ${{ inputs.container_filter }}
        run: |
          set -euo pipefail

          # Get containers to process
          if [[ -n "$CONTAINER_FILTER" ]]; then
            CONTAINERS="$CONTAINER_FILTER"
          else
            CONTAINERS=$(./make list)
          fi

          TOTAL_KEPT=0
          TOTAL_OBSOLETE=0
          TOTAL_ORPHANS=0

          for CONTAINER in $CONTAINERS; do
            echo ""
            echo "========================================"
            echo "Purging obsolete images: $CONTAINER"
            echo "========================================"

            # Get all valid tags from list-builds (resolves current upstream version automatically)
            BUILDS_JSON=$(./make list-builds "$CONTAINER" 2>/dev/null) || {
              echo "  Failed to get builds for $CONTAINER, skipping"
              continue
            }

            if [[ -z "$BUILDS_JSON" || "$BUILDS_JSON" == "[]" ]]; then
              echo "  No builds found, skipping"
              continue
            fi

            # Build valid tag set: tags from builds + "latest" + "latest-{variant}" for variant containers
            VALID_TAGS=$(echo "$BUILDS_JSON" | jq -r '.[].tag')
            VALID_TAGS+=$'\n'"latest"

            # Add latest-{variant} for the newest version's variants
            VARIANT_TAGS=$(echo "$BUILDS_JSON" | jq -r '
              .[] | select(.variant != "" and .is_latest_version == true) |
              "latest-" + .variant
            ' | sort -u)
            if [[ -n "$VARIANT_TAGS" ]]; then
              VALID_TAGS+=$'\n'"$VARIANT_TAGS"
            fi

            # Deduplicate
            VALID_TAGS=$(echo "$VALID_TAGS" | sort -u)

            VALID_COUNT=$(echo "$VALID_TAGS" | wc -l)
            echo "  Valid tags ($VALID_COUNT total):"
            echo "$VALID_TAGS" | sed 's/^/    /'

            # Fetch all GHCR versions
            VERSIONS=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/users/${OWNER}/packages/container/${CONTAINER}/versions" \
              --paginate 2>/dev/null || echo "[]")

            if [[ "$VERSIONS" == "[]" || -z "$VERSIONS" ]]; then
              echo "  No GHCR versions found"
              continue
            fi

            VERSION_COUNT=$(echo "$VERSIONS" | jq 'length')
            echo "  Found $VERSION_COUNT GHCR versions"

            # Save to temp file for two-pass processing: id|digest|tags
            VERSIONS_FILE=$(mktemp)
            echo "$VERSIONS" | jq -r '.[] | "\(.id)|\(.name)|\(.metadata.container.tags // [] | join(","))"' > "$VERSIONS_FILE"

            KEPT=0
            OBSOLETE=0
            ORPHANS=0

            # ── Phase 1: Process tagged versions ──
            KEPT_DIGESTS=()

            while IFS='|' read -r VERSION_ID DIGEST TAGS; do
              [[ -z "$VERSION_ID" ]] && continue
              [[ -z "$TAGS" ]] && continue  # Skip untagged for phase 3

              HAS_VALID=false
              for TAG in $(echo "$TAGS" | tr ',' ' '); do
                if echo "$VALID_TAGS" | grep -qxF "$TAG"; then
                  HAS_VALID=true
                  break
                fi
              done

              if [[ "$HAS_VALID" == "true" ]]; then
                echo "  ✓ Keep (tags: $TAGS)"
                KEPT=$((KEPT + 1))
                KEPT_DIGESTS+=("$DIGEST")
              else
                echo "  ✗ Obsolete (tags: $TAGS)"
                if [[ "$DRY_RUN" == "true" ]]; then
                  echo "    [DRY RUN] Would delete version $VERSION_ID"
                else
                  if gh api \
                    --method DELETE \
                    -H "Accept: application/vnd.github+json" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "/users/${OWNER}/packages/container/${CONTAINER}/versions/${VERSION_ID}" 2>/dev/null; then
                    echo "    ✓ Deleted"
                  else
                    echo "    ✗ Failed to delete"
                  fi
                fi
                OBSOLETE=$((OBSOLETE + 1))
              fi
            done < "$VERSIONS_FILE"

            # ── Phase 2: Resolve manifest list children to find protected digests ──
            if [[ ${#KEPT_DIGESTS[@]} -gt 0 ]]; then
              echo ""
              echo "  Resolving manifest references for ${#KEPT_DIGESTS[@]} kept images..."

              # Get GHCR registry token
              GHCR_TOKEN=$(curl -sf \
                -u "_:${GH_TOKEN}" \
                "https://ghcr.io/token?service=ghcr.io&scope=repository:${OWNER}/${CONTAINER}:pull" \
                | jq -r '.token' 2>/dev/null || echo "")

              if [[ -z "$GHCR_TOKEN" ]]; then
                echo "  ⚠ Failed to get GHCR token, skipping orphan cleanup"
              else
                # Start with kept version digests as protected
                PROTECTED_FILE=$(mktemp)
                printf '%s\n' "${KEPT_DIGESTS[@]}" > "$PROTECTED_FILE"

                FETCH_FAILURES=0
                for DIGEST in "${KEPT_DIGESTS[@]}"; do
                  MANIFEST=$(curl -sf \
                    -H "Authorization: Bearer $GHCR_TOKEN" \
                    -H "Accept: application/vnd.oci.image.index.v1+json,application/vnd.docker.distribution.manifest.list.v2+json,application/vnd.docker.distribution.manifest.v2+json,application/vnd.oci.image.manifest.v1+json" \
                    "https://ghcr.io/v2/${OWNER}/${CONTAINER}/manifests/${DIGEST}" 2>/dev/null || echo "")

                  if [[ -z "$MANIFEST" ]]; then
                    FETCH_FAILURES=$((FETCH_FAILURES + 1))
                    echo "  ⚠ Failed to fetch manifest for ${DIGEST:0:19}..."
                    continue
                  fi

                  CHILDREN=$(echo "$MANIFEST" | jq -r '.manifests[]?.digest // empty' 2>/dev/null || true)
                  if [[ -n "$CHILDREN" ]]; then
                    echo "$CHILDREN" >> "$PROTECTED_FILE"
                  fi
                done

                if [[ "$FETCH_FAILURES" -gt 0 ]]; then
                  echo "  ⚠ $FETCH_FAILURES manifest fetch(es) failed, skipping orphan cleanup for safety"
                else
                  PROTECTED_DIGESTS=$(sort -u "$PROTECTED_FILE")
                  PROTECTED_COUNT=$(echo "$PROTECTED_DIGESTS" | wc -l)
                  echo "  Protected digests: $PROTECTED_COUNT (${#KEPT_DIGESTS[@]} manifests + children)"

                  # ── Phase 3: Delete untagged orphans ──
                  while IFS='|' read -r VERSION_ID DIGEST TAGS; do
                    [[ -z "$VERSION_ID" ]] && continue
                    [[ -n "$TAGS" ]] && continue  # Skip tagged (already processed)

                    if echo "$PROTECTED_DIGESTS" | grep -qxF "$DIGEST"; then
                      KEPT=$((KEPT + 1))
                    else
                      echo "  ✗ Orphan (digest: ${DIGEST:0:19}...)"
                      if [[ "$DRY_RUN" == "true" ]]; then
                        echo "    [DRY RUN] Would delete version $VERSION_ID"
                      else
                        if gh api \
                          --method DELETE \
                          -H "Accept: application/vnd.github+json" \
                          -H "X-GitHub-Api-Version: 2022-11-28" \
                          "/users/${OWNER}/packages/container/${CONTAINER}/versions/${VERSION_ID}" 2>/dev/null; then
                          echo "    ✓ Deleted"
                        else
                          echo "    ✗ Failed to delete"
                        fi
                      fi
                      ORPHANS=$((ORPHANS + 1))
                    fi
                  done < "$VERSIONS_FILE"
                fi

                rm -f "$PROTECTED_FILE"
              fi
            fi

            rm -f "$VERSIONS_FILE"
            TOTAL_KEPT=$((TOTAL_KEPT + KEPT))
            TOTAL_OBSOLETE=$((TOTAL_OBSOLETE + OBSOLETE))
            TOTAL_ORPHANS=$((TOTAL_ORPHANS + ORPHANS))
            echo "  Summary: kept=$KEPT, obsolete=$OBSOLETE, orphans=$ORPHANS"
          done

          echo ""
          echo "========================================"
          echo "Purge Summary"
          echo "========================================"
          echo "Versions kept: $TOTAL_KEPT"
          echo "Obsolete tags purged: $TOTAL_OBSOLETE"
          echo "Orphan images purged: $TOTAL_ORPHANS"
          echo "========================================"
