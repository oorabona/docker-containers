name: Upstream Version Monitor

on:
  schedule:
    - cron: '0 6 * * *'  # 6 AM UTC daily
  workflow_dispatch:
    inputs:
      container:
        description: 'Specific container to check (optional)'
        required: false
        type: string
      debug:
        description: 'Enable debug output'
        required: false
        default: false
        type: boolean

permissions:
  contents: write     # Push version bumps and merge PRs
  pull-requests: write  # Create and merge PRs

jobs:
  check-upstream-versions:
    runs-on: ubuntu-latest
    outputs:
      containers_with_updates: ${{ steps.check.outputs.containers_with_updates }}
      update_count: ${{ steps.check.outputs.update_count }}
      version_info: ${{ steps.check.outputs.version_info }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 0

      - name: Check upstream versions
        id: check
        uses: ./.github/actions/check-upstream-versions
        with:
          container: ${{ github.event.inputs.container }}

      - name: Summary
        run: |
          update_count="${{ steps.check.outputs.update_count }}"
          echo "Found $update_count containers with updates"
          if [ "$update_count" -gt 0 ]; then
            echo "Containers to update: ${{ steps.check.outputs.containers_with_updates }}"
          fi

  create-update-prs:
    needs: check-upstream-versions
    if: needs.check-upstream-versions.outputs.update_count > 0
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        container: ${{ fromJson(needs.check-upstream-versions.outputs.containers_with_updates) }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git for HTTPS
        run: |
          # Ensure git remote uses HTTPS for token authentication
          git remote set-url origin https://github.com/${{ github.repository }}.git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Detect test environment
        id: env_check
        run: |
          if [ "$ACT" = "true" ]; then
            echo "is_local_test=true" >> $GITHUB_OUTPUT
            echo "üß™ Running in local test mode - will skip actual PR creation"
          else
            echo "is_local_test=false" >> $GITHUB_OUTPUT
            echo "üöÄ Running in production mode"
          fi

      - name: Classify version change
        id: classify
        run: |
          # Extract version info for this specific container from the JSON array
          container_name="${{ matrix.container }}"
          version_data=$(echo '${{ needs.check-upstream-versions.outputs.version_info }}' | jq -r --arg c "$container_name" '.[] | select(.container == $c)')
          current_version=$(echo "$version_data" | jq -r '.current_version')
          new_version=$(echo "$version_data" | jq -r '.latest_version')

          chmod +x .github/scripts/classify-version-change.sh
          
          # Run classification and capture outputs (format: change_type=X, reason=Y)
          classification_output=$(.github/scripts/classify-version-change.sh "$current_version" "$new_version")
          
          # Parse outputs using a loop for maintainability
          change_type=""
          reason=""
          while IFS= read -r line; do
            # Skip empty lines and lines without '='
            [ -z "$line" ] && continue
            case "$line" in
              *=*)
                key="${line%%=*}"
                value="${line#*=}"
                case "$key" in
                  change_type) change_type="$value" ;;
                  reason) reason="$value" ;;
                  *) ;; # ignore other keys for now
                esac
                ;;
              *)
                ;; # skip lines without '='
            esac
          done <<< "$classification_output"

          echo "change_type=$change_type" >> $GITHUB_OUTPUT
          echo "current_version=$current_version" >> $GITHUB_OUTPUT
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "reason=$reason" >> $GITHUB_OUTPUT

          echo "Container: ${{ matrix.container }}"
          echo "Change: $current_version -> $new_version ($change_type)"
          echo "Reason: $reason"

      - name: Close duplicate PRs
        id: close_duplicates
        uses: ./.github/actions/close-duplicate-prs
        with:
          container: ${{ matrix.container }}
          new_version: ${{ steps.classify.outputs.new_version }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create rebuild marker
        run: |
          mkdir -p ${{ matrix.container }}
          
          # Generate workflow run URL
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Determine next steps based on change type
          if [[ "${{ steps.classify.outputs.change_type }}" == "major" ]]; then
            NEXT_STEPS="- ‚ö†Ô∏è **Manual review required** for major version changes
          - Review CHANGELOG and breaking changes
          - Test locally if needed"
          else
            NEXT_STEPS="- ‚úÖ **Auto-merge enabled** - will merge automatically once CI passes
          - Build will trigger automatically on merge"
          fi
          
          cat > ${{ matrix.container }}/LAST_REBUILD.md << EOF
          # Container Rebuild Information
          
          | Field | Value |
          |-------|-------|
          | **Container** | \`${{ matrix.container }}\` |
          | **Version Change** | \`${{ steps.classify.outputs.current_version }}\` ‚Üí \`${{ steps.classify.outputs.new_version }}\` |
          | **Change Type** | \`${{ steps.classify.outputs.change_type }}\` |
          | **Rebuild Date** | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |
          | **Triggered By** | Upstream Monitor (automated) |
          | **Reason** | ${{ steps.classify.outputs.reason }} |
          | **Detection Run** | [View Workflow]($WORKFLOW_URL) |
          
          ## Build Status
          
          This file triggers the auto-build workflow when merged to master.
          Build status will be available in GitHub Actions after merge.
          
          ## Next Steps
          
          $NEXT_STEPS
          
          ---
          *Auto-generated by docker-containers automation system*
          EOF

      - name: Import GPG key
        if: steps.close_duplicates.outputs.existing_pr_found != 'true' && steps.env_check.outputs.is_local_test != 'true'
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          git_committer_name: github-actions[bot]
          git_committer_email: 41898282+github-actions[bot]@users.noreply.github.com

      - name: Create Pull Request
        if: steps.close_duplicates.outputs.existing_pr_found != 'true' && steps.env_check.outputs.is_local_test != 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@c0f553fe549906ede9cf27b5156039d195d2ece0 # v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "build(${{ matrix.container }}): update to ${{ steps.classify.outputs.new_version }}"
          committer: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
          title: "${{ steps.classify.outputs.change_type == 'major' && 'üîÑ Major' || 'üöÄ Minor' }}: ${{ matrix.container }} to ${{ steps.classify.outputs.new_version }}"
          body: |
            ## Container Update: ${{ matrix.container }}

            **Version Change:** `${{ steps.classify.outputs.current_version }}` ‚Üí `${{ steps.classify.outputs.new_version }}`
            **Change Type:** `${{ steps.classify.outputs.change_type }}`

            ${{ steps.classify.outputs.change_type == 'major' && '‚ö†Ô∏è **Major version change** - Please review carefully before merging.' || '‚úÖ **Minor/patch update** - Should be safe to merge.' }}

            When merged, this will trigger the auto-build workflow to build and push the updated container.

            ---
            *Auto-generated by Upstream Version Monitor*
          branch: update/${{ matrix.container }}-${{ steps.classify.outputs.new_version }}
          delete-branch: true
          labels: |
            automation
            ${{ matrix.container }}
            ${{ steps.classify.outputs.change_type }}-update
          assignees: ${{ steps.classify.outputs.change_type == 'major' && github.repository_owner || '' }}

      - name: Auto-merge minor updates
        if: steps.classify.outputs.change_type == 'minor' && steps.create_pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
        run: |
          MERGE_TIMEOUT=300  # 5 minutes max

          # Check PR is still open
          pr_state=$(gh pr view "$PR_NUMBER" --json state -q '.state')
          if [ "$pr_state" != "OPEN" ]; then
            echo "PR #$PR_NUMBER is $pr_state, skipping merge"
            exit 0
          fi

          # Wait for CI checks to complete (with timeout)
          if timeout "$MERGE_TIMEOUT" gh pr checks "$PR_NUMBER" --watch; then
            gh pr merge "$PR_NUMBER" --squash
          else
            exit_code=$?
            if [ "$exit_code" -eq 124 ]; then
              echo "::warning::CI checks timed out after ${MERGE_TIMEOUT}s for PR #$PR_NUMBER ‚Äî skipping merge"
            else
              echo "::warning::CI checks failed for PR #$PR_NUMBER ‚Äî skipping merge"
            fi
          fi

      - name: Show PR details (test mode)
        if: steps.env_check.outputs.is_local_test == 'true'
        run: |
          echo "üß™ LOCAL TEST MODE - Would create PR with:"
          echo "   Title: ${{ steps.classify.outputs.change_type == 'major' && 'üîÑ Major' || 'üöÄ Minor' }}: ${{ matrix.container }} to ${{ steps.classify.outputs.new_version }}"
          echo "   Branch: update/${{ matrix.container }}-${{ steps.classify.outputs.new_version }}"
          echo "   Change: ${{ steps.classify.outputs.current_version }} ‚Üí ${{ steps.classify.outputs.new_version }} (${{ steps.classify.outputs.change_type }})"
          echo "   Labels: automation, ${{ matrix.container }}, ${{ steps.classify.outputs.change_type }}-update"
          echo "   Assignees: ${{ steps.classify.outputs.change_type == 'major' && github.repository_owner || '(none - minor update)' }}"
          echo "   Auto-merge: ${{ steps.classify.outputs.change_type == 'minor' && 'Yes (minor update)' || 'No (major update - requires manual review)' }}"

  # Keep postgres base images cached on GHCR to avoid Docker Hub rate limits
  # This runs in parallel with version checks and updates cache if images changed
  update-base-image-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Update postgres base image cache
        shell: bash
        # Cache is required to avoid Docker Hub rate limits on build workflows
        run: |
          source ./helpers/variant-utils.sh

          owner="${{ github.repository_owner }}"
          cache_repo="ghcr.io/$owner/postgres-base"

          # Get base suffix from variants.yaml (e.g., "-alpine")
          base_suffix=$(base_suffix "./postgres")
          [[ -z "$base_suffix" ]] && base_suffix="-alpine"

          echo "üì¶ Checking postgres base image cache (suffix: $base_suffix)"

          updated=0
          skipped=0
          failed=0

          for major_version in $(list_versions "./postgres"); do
            full_tag="${major_version}${base_suffix}"
            source_image="docker.io/library/postgres:${full_tag}"
            cache_image="$cache_repo:${full_tag}"

            echo ""
            echo "üîç Checking $full_tag..."

            # Get source digest from Docker Hub
            source_digest=$(docker buildx imagetools inspect "$source_image" 2>/dev/null | grep -m1 "Digest:" | awk '{print $2}' || echo "")

            if [[ -z "$source_digest" ]]; then
              echo "  ‚ö†Ô∏è Could not get digest from Docker Hub (rate limit?)"
              failed=$((failed + 1))
              continue
            fi

            # Get cache digest from GHCR (if exists)
            cache_digest=$(docker buildx imagetools inspect "$cache_image" 2>/dev/null | grep -m1 "Digest:" | awk '{print $2}' || echo "")

            if [[ "$source_digest" == "$cache_digest" ]]; then
              echo "  ‚úì Cache up-to-date (digest: ${source_digest:0:20}...)"
              skipped=$((skipped + 1))
              continue
            fi

            # Cache is missing or outdated - update it
            if [[ -z "$cache_digest" ]]; then
              echo "  ‚Üí Cache missing, creating..."
            else
              echo "  ‚Üí Cache outdated, updating..."
              echo "    Source: ${source_digest:0:20}..."
              echo "    Cache:  ${cache_digest:0:20}..."
            fi

            # Copy multi-arch image to GHCR
            if docker buildx imagetools create \
              --tag "$cache_image" \
              "$source_image" 2>&1; then
              echo "  ‚úÖ Cached $full_tag (all platforms)"
              updated=$((updated + 1))
            else
              echo "  ‚ö†Ô∏è Failed to cache $full_tag"
              failed=$((failed + 1))
            fi
          done

          echo ""
          echo "üìä Cache update summary: $updated updated, $skipped up-to-date, $failed failed"

          if [[ $failed -gt 0 ]]; then
            echo "::warning::Some images couldn't be cached (Docker Hub rate limit?)"
          fi

          if [[ $updated -gt 0 ]]; then
            echo "::notice::Updated $updated base image(s) in GHCR cache"
          fi
