name: Upstream Version Monitor

on:
  schedule:
    - cron: '0 6 * * *'  # 6 AM UTC daily
  workflow_dispatch:
    inputs:
      container:
        description: 'Specific container to check (optional)'
        required: false
        type: string
      debug:
        description: 'Enable debug output'
        required: false
        default: false
        type: boolean

permissions:
  contents: write     # Push version bumps and merge PRs
  pull-requests: write  # Create and merge PRs
  actions: write       # Trigger auto-build and update-dashboard workflows
  pages: write         # Required by update-dashboard reusable workflow (deploy to Pages)
  id-token: write      # Required by update-dashboard reusable workflow (OIDC for Pages)

jobs:
  check-upstream-versions:
    runs-on: ubuntu-latest
    outputs:
      containers_with_updates: ${{ steps.check.outputs.containers_with_updates }}
      update_count: ${{ steps.check.outputs.update_count }}
      version_info: ${{ steps.check.outputs.version_info }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 0

      - name: Check upstream versions
        id: check
        uses: ./.github/actions/check-upstream-versions
        with:
          container: ${{ github.event.inputs.container }}

      - name: Summary
        run: |
          update_count="${{ steps.check.outputs.update_count }}"
          echo "Found $update_count containers with updates"
          if [ "$update_count" -gt 0 ]; then
            echo "Containers to update: ${{ steps.check.outputs.containers_with_updates }}"
          fi

  create-update-prs:
    needs: check-upstream-versions
    if: needs.check-upstream-versions.outputs.update_count > 0
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 1  # Serialize to avoid "base branch was modified" race on merge
      matrix:
        container: ${{ fromJson(needs.check-upstream-versions.outputs.containers_with_updates) }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git for HTTPS
        run: |
          # Ensure git remote uses HTTPS for token authentication
          git remote set-url origin https://github.com/${{ github.repository }}.git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "oorabona@users.noreply.github.com"

      - name: Detect test environment
        id: env_check
        run: |
          if [ "$ACT" = "true" ]; then
            echo "is_local_test=true" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Running in local test mode - will skip actual PR creation"
          else
            echo "is_local_test=false" >> $GITHUB_OUTPUT
            echo "ðŸš€ Running in production mode"
          fi

      - name: Classify version change
        id: classify
        run: |
          # Extract version info for this specific container from the JSON array
          container_name="${{ matrix.container }}"
          version_data=$(echo '${{ needs.check-upstream-versions.outputs.version_info }}' | jq -r --arg c "$container_name" '.[] | select(.container == $c)')
          current_version=$(echo "$version_data" | jq -r '.current_version')
          new_version=$(echo "$version_data" | jq -r '.latest_version')

          chmod +x .github/scripts/classify-version-change.sh
          
          # Run classification and capture outputs (format: change_type=X, reason=Y)
          classification_output=$(.github/scripts/classify-version-change.sh "$current_version" "$new_version")
          
          # Parse outputs using a loop for maintainability
          change_type=""
          reason=""
          while IFS= read -r line; do
            # Skip empty lines and lines without '='
            [ -z "$line" ] && continue
            case "$line" in
              *=*)
                key="${line%%=*}"
                value="${line#*=}"
                case "$key" in
                  change_type) change_type="$value" ;;
                  reason) reason="$value" ;;
                  *) ;; # ignore other keys for now
                esac
                ;;
              *)
                ;; # skip lines without '='
            esac
          done <<< "$classification_output"

          echo "change_type=$change_type" >> $GITHUB_OUTPUT
          echo "current_version=$current_version" >> $GITHUB_OUTPUT
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "reason=$reason" >> $GITHUB_OUTPUT

          echo "Container: ${{ matrix.container }}"
          echo "Change: $current_version -> $new_version ($change_type)"
          echo "Reason: $reason"

      - name: Close duplicate PRs
        id: close_duplicates
        uses: ./.github/actions/close-duplicate-prs
        with:
          container: ${{ matrix.container }}
          new_version: ${{ steps.classify.outputs.new_version }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create rebuild marker
        run: |
          mkdir -p ${{ matrix.container }}
          
          # Generate workflow run URL
          WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Determine next steps based on change type
          if [[ "${{ steps.classify.outputs.change_type }}" == "major" ]]; then
            NEXT_STEPS="- âš ï¸ **Manual review required** for major version changes
          - Review CHANGELOG and breaking changes
          - Test locally if needed"
          else
            NEXT_STEPS="- âœ… **Auto-merge enabled** - will merge automatically once CI passes
          - Build will trigger automatically on merge"
          fi
          
          cat > ${{ matrix.container }}/LAST_REBUILD.md << EOF
          # Container Rebuild Information
          
          | Field | Value |
          |-------|-------|
          | **Container** | \`${{ matrix.container }}\` |
          | **Version Change** | \`${{ steps.classify.outputs.current_version }}\` â†’ \`${{ steps.classify.outputs.new_version }}\` |
          | **Change Type** | \`${{ steps.classify.outputs.change_type }}\` |
          | **Rebuild Date** | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |
          | **Triggered By** | Upstream Monitor (automated) |
          | **Reason** | ${{ steps.classify.outputs.reason }} |
          | **Detection Run** | [View Workflow]($WORKFLOW_URL) |
          
          ## Build Status
          
          This file triggers the auto-build workflow when merged to master.
          Build status will be available in GitHub Actions after merge.
          
          ## Next Steps
          
          $NEXT_STEPS
          
          ---
          *Auto-generated by docker-containers automation system*
          EOF

      - name: Import GPG key
        if: steps.close_duplicates.outputs.existing_pr_found != 'true' && steps.env_check.outputs.is_local_test != 'true'
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          git_committer_name: github-actions[bot]
          git_committer_email: oorabona@users.noreply.github.com

      - name: Create Pull Request
        if: steps.close_duplicates.outputs.existing_pr_found != 'true' && steps.env_check.outputs.is_local_test != 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@c0f553fe549906ede9cf27b5156039d195d2ece0 # v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "build(${{ matrix.container }}): update to ${{ steps.classify.outputs.new_version }}"
          committer: github-actions[bot] <oorabona@users.noreply.github.com>
          title: "${{ steps.classify.outputs.change_type == 'major' && 'ðŸ”„ Major' || 'ðŸš€ Minor' }}: ${{ matrix.container }} to ${{ steps.classify.outputs.new_version }}"
          body: |
            ## Container Update: ${{ matrix.container }}

            **Version Change:** `${{ steps.classify.outputs.current_version }}` â†’ `${{ steps.classify.outputs.new_version }}`
            **Change Type:** `${{ steps.classify.outputs.change_type }}`

            ${{ steps.classify.outputs.change_type == 'major' && 'âš ï¸ **Major version change** - Please review carefully before merging.' || 'âœ… **Minor/patch update** - Should be safe to merge.' }}

            When merged, this will trigger the auto-build workflow to build and push the updated container.

            ---
            *Auto-generated by Upstream Version Monitor*
          branch: update/${{ matrix.container }}-${{ steps.classify.outputs.new_version }}
          delete-branch: true
          labels: |
            automation
            ${{ matrix.container }}
            ${{ steps.classify.outputs.change_type }}-update
          assignees: ${{ steps.classify.outputs.change_type == 'major' && github.repository_owner || '' }}

      - name: Auto-merge minor updates
        id: merge_pr
        if: steps.classify.outputs.change_type == 'minor' && steps.create_pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
        run: |
          MERGE_TIMEOUT=300  # 5 minutes max
          MAX_RETRIES=3
          RETRY_DELAY=30

          # Check PR is still open
          pr_state=$(gh pr view "$PR_NUMBER" --json state -q '.state')
          if [ "$pr_state" != "OPEN" ]; then
            echo "PR #$PR_NUMBER is $pr_state, skipping merge"
            exit 0
          fi

          # Wait for CI checks to complete (with timeout)
          if timeout "$MERGE_TIMEOUT" gh pr checks "$PR_NUMBER" --watch; then
            # Try to merge with retries (handles "base branch was modified" race)
            for attempt in $(seq 1 $MAX_RETRIES); do
              if gh pr merge "$PR_NUMBER" --squash 2>&1; then
                echo "merged=true" >> "$GITHUB_OUTPUT"
                echo "âœ… Auto-merged PR #$PR_NUMBER"
                exit 0
              fi
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                echo "âš ï¸ Merge attempt $attempt/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
                sleep "$RETRY_DELAY"
                # Re-verify checks are still green after base branch update
                timeout 120 gh pr checks "$PR_NUMBER" --watch 2>/dev/null || true
              fi
            done
            echo "::warning::Failed to merge PR #$PR_NUMBER after $MAX_RETRIES attempts"
            echo "merged=false" >> "$GITHUB_OUTPUT"
          else
            exit_code=$?
            if [ "$exit_code" -eq 124 ]; then
              echo "::warning::CI checks timed out after ${MERGE_TIMEOUT}s for PR #$PR_NUMBER â€” skipping merge"
            else
              echo "::warning::CI checks failed for PR #$PR_NUMBER â€” skipping merge"
            fi
            echo "merged=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Trigger container build
        if: steps.env_check.outputs.is_local_test != 'true' && steps.merge_pr.outputs.merged == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CONTAINER: ${{ matrix.container }}
        run: |
          echo "ðŸ”¨ Triggering build for $CONTAINER after successful merge"
          gh workflow run auto-build.yaml -f container="$CONTAINER" -f force_rebuild=true
          echo "âœ… Build workflow triggered for $CONTAINER"

      - name: Show PR details (test mode)
        if: steps.env_check.outputs.is_local_test == 'true'
        run: |
          echo "ðŸ§ª LOCAL TEST MODE - Would create PR with:"
          echo "   Title: ${{ steps.classify.outputs.change_type == 'major' && 'ðŸ”„ Major' || 'ðŸš€ Minor' }}: ${{ matrix.container }} to ${{ steps.classify.outputs.new_version }}"
          echo "   Branch: update/${{ matrix.container }}-${{ steps.classify.outputs.new_version }}"
          echo "   Change: ${{ steps.classify.outputs.current_version }} â†’ ${{ steps.classify.outputs.new_version }} (${{ steps.classify.outputs.change_type }})"
          echo "   Labels: automation, ${{ matrix.container }}, ${{ steps.classify.outputs.change_type }}-update"
          echo "   Assignees: ${{ steps.classify.outputs.change_type == 'major' && github.repository_owner || '(none - minor update)' }}"
          echo "   Auto-merge: ${{ steps.classify.outputs.change_type == 'minor' && 'Yes (minor update)' || 'No (major update - requires manual review)' }}"

  # Update dashboard after PRs are merged to reflect new versions
  update-dashboard:
    needs: [create-update-prs, create-dependency-update-prs]
    if: always() && (needs.create-update-prs.result == 'success' || needs.create-dependency-update-prs.result == 'success')
    uses: ./.github/workflows/update-dashboard.yaml
    with:
      trigger_reason: "Post upstream-monitor PR merge"

  # Keep postgres base images cached on GHCR to avoid Docker Hub rate limits
  # This runs in parallel with version checks and updates cache if images changed
  update-base-image-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Update postgres base image cache
        shell: bash
        # Cache is required to avoid Docker Hub rate limits on build workflows
        run: |
          source ./helpers/variant-utils.sh

          owner="${{ github.repository_owner }}"
          cache_repo="ghcr.io/$owner/postgres-base"

          # Get base suffix from variants.yaml (e.g., "-alpine")
          base_suffix=$(base_suffix "./postgres")
          [[ -z "$base_suffix" ]] && base_suffix="-alpine"

          echo "ðŸ“¦ Checking postgres base image cache (suffix: $base_suffix)"

          updated=0
          skipped=0
          failed=0

          for major_version in $(list_versions "./postgres"); do
            full_tag="${major_version}${base_suffix}"
            source_image="docker.io/library/postgres:${full_tag}"
            cache_image="$cache_repo:${full_tag}"

            echo ""
            echo "ðŸ” Checking $full_tag..."

            # Get source digest from Docker Hub
            source_digest=$(docker buildx imagetools inspect "$source_image" 2>/dev/null | grep -m1 "Digest:" | awk '{print $2}' || echo "")

            if [[ -z "$source_digest" ]]; then
              echo "  âš ï¸ Could not get digest from Docker Hub (rate limit?)"
              failed=$((failed + 1))
              continue
            fi

            # Get cache digest from GHCR (if exists)
            cache_digest=$(docker buildx imagetools inspect "$cache_image" 2>/dev/null | grep -m1 "Digest:" | awk '{print $2}' || echo "")

            if [[ "$source_digest" == "$cache_digest" ]]; then
              echo "  âœ“ Cache up-to-date (digest: ${source_digest:0:20}...)"
              skipped=$((skipped + 1))
              continue
            fi

            # Cache is missing or outdated - update it
            if [[ -z "$cache_digest" ]]; then
              echo "  â†’ Cache missing, creating..."
            else
              echo "  â†’ Cache outdated, updating..."
              echo "    Source: ${source_digest:0:20}..."
              echo "    Cache:  ${cache_digest:0:20}..."
            fi

            # Copy multi-arch image to GHCR
            if docker buildx imagetools create \
              --tag "$cache_image" \
              "$source_image" 2>&1; then
              echo "  âœ… Cached $full_tag (all platforms)"
              updated=$((updated + 1))
            else
              echo "  âš ï¸ Failed to cache $full_tag"
              failed=$((failed + 1))
            fi
          done

          echo ""
          echo "ðŸ“Š Cache update summary: $updated updated, $skipped up-to-date, $failed failed"

          if [[ $failed -gt 0 ]]; then
            echo "::warning::Some images couldn't be cached (Docker Hub rate limit?)"
          fi

          if [[ $updated -gt 0 ]]; then
            echo "::notice::Updated $updated base image(s) in GHCR cache"
          fi

  # Check 3rd party dependency versions (runs in parallel with base image checks)
  check-dependency-updates:
    runs-on: ubuntu-latest
    outputs:
      containers_with_dep_updates: ${{ steps.check.outputs.containers_with_dep_updates }}
      dep_update_count: ${{ steps.check.outputs.dep_update_count }}
      dep_version_info: ${{ steps.check.outputs.dep_version_info }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

      - name: Check dependency versions
        id: check
        uses: ./.github/actions/check-dependency-versions
        with:
          container: ${{ github.event.inputs.container }}

      - name: Summary
        env:
          DEP_COUNT: ${{ steps.check.outputs.dep_update_count }}
          CONTAINERS: ${{ steps.check.outputs.containers_with_dep_updates }}
        run: |
          echo "Found $DEP_COUNT dependency update(s)"
          if [ "$DEP_COUNT" -gt 0 ]; then
            echo "Containers with dep updates: $CONTAINERS"
          fi

  create-dependency-update-prs:
    needs: [check-dependency-updates, create-update-prs]
    if: always() && needs.check-dependency-updates.outputs.dep_update_count > 0
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 1  # Serialize to avoid "base branch was modified" race on merge
      matrix:
        container: ${{ fromJson(needs.check-dependency-updates.outputs.containers_with_dep_updates) }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq \
            https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Configure Git
        run: |
          git remote set-url origin "https://github.com/${{ github.repository }}.git"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "oorabona@users.noreply.github.com"

      - name: Detect test environment
        id: env_check
        run: |
          if [ "$ACT" = "true" ]; then
            echo "is_local_test=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_local_test=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare dependency updates
        id: prepare
        env:
          CONTAINER: ${{ matrix.container }}
          DEP_INFO: ${{ needs.check-dependency-updates.outputs.dep_version_info }}
        run: |
          # Extract updates for this container (using env vars to avoid injection)
          container_data=$(echo "$DEP_INFO" | jq --arg c "$CONTAINER" '.[] | select(.container == $c)')
          updates=$(echo "$container_data" | jq -c '.updates')
          update_count=$(echo "$container_data" | jq '.update_count')

          echo "ðŸ“¦ Processing $update_count update(s) for $CONTAINER"

          # Determine max severity (major > minor > patch)
          max_severity="patch"
          if echo "$updates" | jq -e '.[] | select(.change_type == "major")' &>/dev/null; then
            max_severity="major"
          elif echo "$updates" | jq -e '.[] | select(.change_type == "minor")' &>/dev/null; then
            max_severity="minor"
          fi

          echo "max_severity=$max_severity" >> "$GITHUB_OUTPUT"
          echo "update_count=$update_count" >> "$GITHUB_OUTPUT"

          # Build PR body table
          pr_table="| Dependency | Current | New | Change | Release |"
          pr_table="$pr_table
          |------------|---------|-----|--------|---------|"

          while IFS= read -r update; do
            name=$(echo "$update" | jq -r '.name')
            current=$(echo "$update" | jq -r '.current')
            latest=$(echo "$update" | jq -r '.latest')
            change_type=$(echo "$update" | jq -r '.change_type')
            source_url=$(echo "$update" | jq -r '.source_url')
            pr_table="$pr_table
          | $name | $current | $latest | $change_type | [Release notes]($source_url) |"
          done < <(echo "$updates" | jq -c '.[]')

          {
            echo "pr_table<<EOF"
            echo "$pr_table"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "updates<<EOF"
            echo "$updates"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Apply dependency updates
        env:
          CONTAINER: ${{ matrix.container }}
          UPDATES: ${{ steps.prepare.outputs.updates }}
        run: |
          if [ "$CONTAINER" = "postgres" ]; then
            # Postgres: update extensions/config.yaml
            while IFS= read -r update; do
              name=$(echo "$update" | jq -r '.name')
              latest=$(echo "$update" | jq -r '.latest')
              echo "  Updating postgres extension $name to $latest"
              yq -i ".extensions.${name}.version = \"$latest\"" "postgres/extensions/config.yaml" || { echo "::error::Failed to update postgres extension ${name} config"; exit 1; }
            done < <(echo "$UPDATES" | jq -c '.[]')
          else
            # Other containers: update config.yaml build_args
            while IFS= read -r update; do
              name=$(echo "$update" | jq -r '.name')
              latest=$(echo "$update" | jq -r '.latest')
              echo "  Updating ${CONTAINER} build_arg $name to $latest"
              yq -i ".build_args.${name} = \"$latest\"" "${CONTAINER}/config.yaml"
            done < <(echo "$UPDATES" | jq -c '.[]')
          fi

      - name: Import GPG key
        if: steps.env_check.outputs.is_local_test != 'true'
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          git_committer_name: github-actions[bot]
          git_committer_email: oorabona@users.noreply.github.com

      - name: Create Pull Request
        if: steps.env_check.outputs.is_local_test != 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@c0f553fe549906ede9cf27b5156039d195d2ece0 # v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "deps(${{ matrix.container }}): update ${{ steps.prepare.outputs.update_count }} dependencies"
          committer: github-actions[bot] <oorabona@users.noreply.github.com>
          title: "${{ steps.prepare.outputs.max_severity == 'major' && 'âš ï¸' || 'ðŸ“¦' }} deps(${{ matrix.container }}): update ${{ steps.prepare.outputs.update_count }} dependencies"
          body: |
            ## Dependency updates for ${{ matrix.container }}

            ${{ steps.prepare.outputs.pr_table }}

            **Change classification:** ${{ steps.prepare.outputs.max_severity }} ${{ steps.prepare.outputs.max_severity == 'major' && '(manual review required)' || '(auto-merge eligible)' }}

            Updated by: upstream-monitor / dependency-check
          branch: update/${{ matrix.container }}-deps
          delete-branch: true
          labels: |
            automation
            dependencies
            ${{ matrix.container }}
            ${{ steps.prepare.outputs.max_severity }}-update
          assignees: ${{ steps.prepare.outputs.max_severity == 'major' && github.repository_owner || '' }}

      - name: Auto-merge minor/patch updates
        id: merge_dep_pr
        if: steps.prepare.outputs.max_severity != 'major' && steps.create_pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
        run: |
          MERGE_TIMEOUT=300  # 5 minutes max
          MAX_RETRIES=3
          RETRY_DELAY=30

          pr_state=$(gh pr view "$PR_NUMBER" --json state -q '.state')
          if [ "$pr_state" != "OPEN" ]; then
            echo "PR #$PR_NUMBER is $pr_state, skipping merge"
            exit 0
          fi

          if timeout "$MERGE_TIMEOUT" gh pr checks "$PR_NUMBER" --watch; then
            # Try to merge with retries (handles "base branch was modified" race)
            for attempt in $(seq 1 $MAX_RETRIES); do
              if gh pr merge "$PR_NUMBER" --squash 2>&1; then
                echo "merged=true" >> "$GITHUB_OUTPUT"
                echo "âœ… Auto-merged PR #$PR_NUMBER"
                exit 0
              fi
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                echo "âš ï¸ Merge attempt $attempt/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
                sleep "$RETRY_DELAY"
                # Re-verify checks are still green after base branch update
                timeout 120 gh pr checks "$PR_NUMBER" --watch 2>/dev/null || true
              fi
            done
            echo "::warning::Failed to merge PR #$PR_NUMBER after $MAX_RETRIES attempts"
            echo "merged=false" >> "$GITHUB_OUTPUT"
          else
            exit_code=$?
            if [ "$exit_code" -eq 124 ]; then
              echo "::warning::CI checks timed out after ${MERGE_TIMEOUT}s for PR #$PR_NUMBER â€” skipping merge"
            else
              echo "::warning::CI checks failed for PR #$PR_NUMBER â€” skipping merge"
            fi
            echo "merged=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Trigger container build
        if: steps.env_check.outputs.is_local_test != 'true' && steps.merge_dep_pr.outputs.merged == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CONTAINER: ${{ matrix.container }}
        run: |
          echo "ðŸ”¨ Triggering build for $CONTAINER after dependency update merge"
          gh workflow run auto-build.yaml -f container="$CONTAINER" -f force_rebuild=true
          echo "âœ… Build workflow triggered for $CONTAINER"

      - name: Show PR details (test mode)
        if: steps.env_check.outputs.is_local_test == 'true'
        env:
          CONTAINER: ${{ matrix.container }}
          UPDATE_COUNT: ${{ steps.prepare.outputs.update_count }}
          MAX_SEVERITY: ${{ steps.prepare.outputs.max_severity }}
        run: |
          echo "ðŸ§ª LOCAL TEST MODE - Would create dep update PR with:"
          echo "   Container: $CONTAINER"
          echo "   Updates: $UPDATE_COUNT"
          echo "   Max severity: $MAX_SEVERITY"
          echo "   Branch: update/${CONTAINER}-deps"
